//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 3.4.1.9004
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// $ANTLR 3.4.1.9004 C:\\Users\\Alexandr\\Sources\\Repos\\Expressions\\Expressions\\Flee\\Flee.g 2017-01-05 07:21:08

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
// Unreachable code detected.
#pragma warning disable 162
// Missing XML comment for publicly visible type or member 'Type_or_Member'
#pragma warning disable 1591
// CLS compliance checking will not be performed on 'type' because it is not visible from outside this assembly.
#pragma warning disable 3019


	using Expressions.Ast;


using System.Collections.Generic;
using Antlr.Runtime;
using Antlr.Runtime.Misc;


using Antlr.Runtime.Tree;
using RewriteRuleITokenStream = Antlr.Runtime.Tree.RewriteRuleTokenStream;

namespace  Expressions.Flee 
{
[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.4.1.9004")]
[System.CLSCompliant(false)]
 internal  partial class FleeParser : Antlr.Runtime.Parser
{
	internal static readonly string[] tokenNames = new string[] {
		"<invalid>", "<EOR>", "<DOWN>", "<UP>", "AND", "CAST", "CHARACTER_LITERAL", "DATETIME_LITERAL", "DECIMAL_LITERAL", "DOT", "Digits", "EscapeSequence", "Exponent", "FALSE", "FLOATING_POINT_LITERAL", "FloatTypeSuffix", "HEX_LITERAL", "HexDigit", "IDENTIFIER", "IF", "IN", "LETTER", "NOT", "NULL", "NumericTypeSuffix", "OR", "STRING_LITERAL", "TIMESPAN_LITERAL", "TRUE", "UnicodeEscape", "WS", "XOR", "'%'", "'('", "')'", "'*'", "'+'", "','", "'-'", "'/'", "'<'", "'<<'", "'<='", "'<>'", "'='", "'>'", "'>='", "'>>'", "'['", "']'", "'^'"
	};
	public const int EOF=-1;
	public const int AND=4;
	public const int CAST=5;
	public const int CHARACTER_LITERAL=6;
	public const int DATETIME_LITERAL=7;
	public const int DECIMAL_LITERAL=8;
	public const int DOT=9;
	public const int Digits=10;
	public const int EscapeSequence=11;
	public const int Exponent=12;
	public const int FALSE=13;
	public const int FLOATING_POINT_LITERAL=14;
	public const int FloatTypeSuffix=15;
	public const int HEX_LITERAL=16;
	public const int HexDigit=17;
	public const int IDENTIFIER=18;
	public const int IF=19;
	public const int IN=20;
	public const int LETTER=21;
	public const int NOT=22;
	public const int NULL=23;
	public const int NumericTypeSuffix=24;
	public const int OR=25;
	public const int STRING_LITERAL=26;
	public const int TIMESPAN_LITERAL=27;
	public const int TRUE=28;
	public const int UnicodeEscape=29;
	public const int WS=30;
	public const int XOR=31;
	public const int T__32=32;
	public const int T__33=33;
	public const int T__34=34;
	public const int T__35=35;
	public const int T__36=36;
	public const int T__37=37;
	public const int T__38=38;
	public const int T__39=39;
	public const int T__40=40;
	public const int T__41=41;
	public const int T__42=42;
	public const int T__43=43;
	public const int T__44=44;
	public const int T__45=45;
	public const int T__46=46;
	public const int T__47=47;
	public const int T__48=48;
	public const int T__49=49;
	public const int T__50=50;

	public FleeParser(ITokenStream input)
		: this(input, new RecognizerSharedState())
	{
	}
	public FleeParser(ITokenStream input, RecognizerSharedState state)
		: base(input, state)
	{
		ITreeAdaptor treeAdaptor = default(ITreeAdaptor);
		CreateTreeAdaptor(ref treeAdaptor);
		TreeAdaptor = treeAdaptor ?? new CommonTreeAdaptor();
		OnCreated();
	}
	// Implement this function in your helper file to use a custom tree adaptor
	partial void CreateTreeAdaptor(ref ITreeAdaptor adaptor);

	private ITreeAdaptor adaptor;

	public ITreeAdaptor TreeAdaptor
	{
		get
		{
			return adaptor;
		}

		set
		{
			this.adaptor = value;
		}
	}

	public override string[] TokenNames { get { return FleeParser.tokenNames; } }
	public override string GrammarFileName { get { return "C:\\Users\\Alexandr\\Sources\\Repos\\Expressions\\Expressions\\Flee\\Flee.g"; } }


	partial void OnCreated();
	partial void EnterRule(string ruleName, int ruleIndex);
	partial void LeaveRule(string ruleName, int ruleIndex);

	#region Rules
	private sealed partial class prog_return : AstParserRuleReturnScope<CommonTree, CommonToken>
	{
		public IAstNode value;
		public prog_return(FleeParser grammar) {OnCreated(grammar);}
		partial void OnCreated(FleeParser grammar);
	}

	partial void EnterRule_prog();
	partial void LeaveRule_prog();
	// $ANTLR start "prog"
	// C:\\Users\\Alexandr\\Sources\\Repos\\Expressions\\Expressions\\Flee\\Flee.g:29:1: prog returns [IAstNode value] : expression EOF ;
	[GrammarRule("prog")]
	private FleeParser.prog_return prog()
	{
		EnterRule_prog();
		EnterRule("prog", 1);
		TraceIn("prog", 1);
		FleeParser.prog_return retval = new FleeParser.prog_return(this);
		retval.Start = (CommonToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		CommonToken EOF2 = default(CommonToken);
		FleeParser.expression_return expression1 = default(FleeParser.expression_return);

		CommonTree EOF2_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "prog");
		DebugLocation(29, 1);
		try
		{
			// C:\\Users\\Alexandr\\Sources\\Repos\\Expressions\\Expressions\\Flee\\Flee.g:30:2: ( expression EOF )
			DebugEnterAlt(1);
			// C:\\Users\\Alexandr\\Sources\\Repos\\Expressions\\Expressions\\Flee\\Flee.g:30:4: expression EOF
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(30, 4);
			PushFollow(Follow._expression_in_prog97);
			expression1=expression();
			PopFollow();

			adaptor.AddChild(root_0, expression1.Tree);
			DebugLocation(30, 15);
			 retval.value = (expression1!=null?expression1.value:default(IAstNode)); 
			DebugLocation(30, 47);
			EOF2=(CommonToken)Match(input,EOF,Follow._EOF_in_prog101); 
			EOF2_tree = (CommonTree)adaptor.Create(EOF2);
			adaptor.AddChild(root_0, EOF2_tree);

			}

			retval.Stop = (CommonToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}

		    catch (RecognitionException) 
		    {
		        throw;
		    }

		finally
		{
			TraceOut("prog", 1);
			LeaveRule("prog", 1);
			LeaveRule_prog();
		}
		DebugLocation(31, 1);
		} finally { DebugExitRule(GrammarFileName, "prog"); }
		return retval;

	}
	// $ANTLR end "prog"

	private sealed partial class expression_return : AstParserRuleReturnScope<CommonTree, CommonToken>
	{
		public IAstNode value;
		public expression_return(FleeParser grammar) {OnCreated(grammar);}
		partial void OnCreated(FleeParser grammar);
	}

	partial void EnterRule_expression();
	partial void LeaveRule_expression();
	// $ANTLR start "expression"
	// C:\\Users\\Alexandr\\Sources\\Repos\\Expressions\\Expressions\\Flee\\Flee.g:33:1: expression returns [IAstNode value] : e= logical_xor_expression ( OR e= logical_xor_expression )* ;
	[GrammarRule("expression")]
	private FleeParser.expression_return expression()
	{
		EnterRule_expression();
		EnterRule("expression", 2);
		TraceIn("expression", 2);
		FleeParser.expression_return retval = new FleeParser.expression_return(this);
		retval.Start = (CommonToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		CommonToken OR3 = default(CommonToken);
		FleeParser.logical_xor_expression_return e = default(FleeParser.logical_xor_expression_return);

		CommonTree OR3_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "expression");
		DebugLocation(33, 1);
		try
		{
			// C:\\Users\\Alexandr\\Sources\\Repos\\Expressions\\Expressions\\Flee\\Flee.g:34:2: (e= logical_xor_expression ( OR e= logical_xor_expression )* )
			DebugEnterAlt(1);
			// C:\\Users\\Alexandr\\Sources\\Repos\\Expressions\\Expressions\\Flee\\Flee.g:34:4: e= logical_xor_expression ( OR e= logical_xor_expression )*
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(34, 5);
			PushFollow(Follow._logical_xor_expression_in_expression118);
			e=logical_xor_expression();
			PopFollow();

			adaptor.AddChild(root_0, e.Tree);
			DebugLocation(34, 29);
			 retval.value = (e!=null?e.value:default(IAstNode)); 
			DebugLocation(35, 3);
			// C:\\Users\\Alexandr\\Sources\\Repos\\Expressions\\Expressions\\Flee\\Flee.g:35:3: ( OR e= logical_xor_expression )*
			try { DebugEnterSubRule(1);
			while (true)
			{
				int alt1=2;
				try { DebugEnterDecision(1, false);
				int LA1_1 = input.LA(1);

				if ((LA1_1==OR))
				{
					alt1 = 1;
				}


				} finally { DebugExitDecision(1); }
				switch ( alt1 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\Alexandr\\Sources\\Repos\\Expressions\\Expressions\\Flee\\Flee.g:35:5: OR e= logical_xor_expression
					{
					DebugLocation(35, 5);
					OR3=(CommonToken)Match(input,OR,Follow._OR_in_expression126); 
					OR3_tree = (CommonTree)adaptor.Create(OR3);
					adaptor.AddChild(root_0, OR3_tree);
					DebugLocation(35, 9);
					PushFollow(Follow._logical_xor_expression_in_expression130);
					e=logical_xor_expression();
					PopFollow();

					adaptor.AddChild(root_0, e.Tree);
					DebugLocation(36, 5);
					 retval.value = new BinaryExpression(retval.value, (e!=null?e.value:default(IAstNode)), ExpressionType.Or); 

					}
					break;

				default:
					goto loop1;
				}
			}

			loop1:
				;

			} finally { DebugExitSubRule(1); }


			}

			retval.Stop = (CommonToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}

		    catch (RecognitionException) 
		    {
		        throw;
		    }

		finally
		{
			TraceOut("expression", 2);
			LeaveRule("expression", 2);
			LeaveRule_expression();
		}
		DebugLocation(38, 1);
		} finally { DebugExitRule(GrammarFileName, "expression"); }
		return retval;

	}
	// $ANTLR end "expression"

	private sealed partial class logical_xor_expression_return : AstParserRuleReturnScope<CommonTree, CommonToken>
	{
		public IAstNode value;
		public logical_xor_expression_return(FleeParser grammar) {OnCreated(grammar);}
		partial void OnCreated(FleeParser grammar);
	}

	partial void EnterRule_logical_xor_expression();
	partial void LeaveRule_logical_xor_expression();
	// $ANTLR start "logical_xor_expression"
	// C:\\Users\\Alexandr\\Sources\\Repos\\Expressions\\Expressions\\Flee\\Flee.g:40:1: logical_xor_expression returns [IAstNode value] : e= logical_and_expression ( XOR e= logical_and_expression )* ;
	[GrammarRule("logical_xor_expression")]
	private FleeParser.logical_xor_expression_return logical_xor_expression()
	{
		EnterRule_logical_xor_expression();
		EnterRule("logical_xor_expression", 3);
		TraceIn("logical_xor_expression", 3);
		FleeParser.logical_xor_expression_return retval = new FleeParser.logical_xor_expression_return(this);
		retval.Start = (CommonToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		CommonToken XOR4 = default(CommonToken);
		FleeParser.logical_and_expression_return e = default(FleeParser.logical_and_expression_return);

		CommonTree XOR4_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "logical_xor_expression");
		DebugLocation(40, 1);
		try
		{
			// C:\\Users\\Alexandr\\Sources\\Repos\\Expressions\\Expressions\\Flee\\Flee.g:41:2: (e= logical_and_expression ( XOR e= logical_and_expression )* )
			DebugEnterAlt(1);
			// C:\\Users\\Alexandr\\Sources\\Repos\\Expressions\\Expressions\\Flee\\Flee.g:41:4: e= logical_and_expression ( XOR e= logical_and_expression )*
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(41, 5);
			PushFollow(Follow._logical_and_expression_in_logical_xor_expression158);
			e=logical_and_expression();
			PopFollow();

			adaptor.AddChild(root_0, e.Tree);
			DebugLocation(41, 29);
			 retval.value = (e!=null?e.value:default(IAstNode)); 
			DebugLocation(42, 3);
			// C:\\Users\\Alexandr\\Sources\\Repos\\Expressions\\Expressions\\Flee\\Flee.g:42:3: ( XOR e= logical_and_expression )*
			try { DebugEnterSubRule(2);
			while (true)
			{
				int alt2=2;
				try { DebugEnterDecision(2, false);
				int LA2_1 = input.LA(1);

				if ((LA2_1==XOR))
				{
					alt2 = 1;
				}


				} finally { DebugExitDecision(2); }
				switch ( alt2 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\Alexandr\\Sources\\Repos\\Expressions\\Expressions\\Flee\\Flee.g:42:5: XOR e= logical_and_expression
					{
					DebugLocation(42, 5);
					XOR4=(CommonToken)Match(input,XOR,Follow._XOR_in_logical_xor_expression166); 
					XOR4_tree = (CommonTree)adaptor.Create(XOR4);
					adaptor.AddChild(root_0, XOR4_tree);
					DebugLocation(42, 10);
					PushFollow(Follow._logical_and_expression_in_logical_xor_expression170);
					e=logical_and_expression();
					PopFollow();

					adaptor.AddChild(root_0, e.Tree);
					DebugLocation(43, 5);
					 retval.value = new BinaryExpression(retval.value, (e!=null?e.value:default(IAstNode)), ExpressionType.Xor); 

					}
					break;

				default:
					goto loop2;
				}
			}

			loop2:
				;

			} finally { DebugExitSubRule(2); }


			}

			retval.Stop = (CommonToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}

		    catch (RecognitionException) 
		    {
		        throw;
		    }

		finally
		{
			TraceOut("logical_xor_expression", 3);
			LeaveRule("logical_xor_expression", 3);
			LeaveRule_logical_xor_expression();
		}
		DebugLocation(45, 1);
		} finally { DebugExitRule(GrammarFileName, "logical_xor_expression"); }
		return retval;

	}
	// $ANTLR end "logical_xor_expression"

	private sealed partial class logical_and_expression_return : AstParserRuleReturnScope<CommonTree, CommonToken>
	{
		public IAstNode value;
		public logical_and_expression_return(FleeParser grammar) {OnCreated(grammar);}
		partial void OnCreated(FleeParser grammar);
	}

	partial void EnterRule_logical_and_expression();
	partial void LeaveRule_logical_and_expression();
	// $ANTLR start "logical_and_expression"
	// C:\\Users\\Alexandr\\Sources\\Repos\\Expressions\\Expressions\\Flee\\Flee.g:47:1: logical_and_expression returns [IAstNode value] : e= unary_not_expression ( AND e= unary_not_expression )* ;
	[GrammarRule("logical_and_expression")]
	private FleeParser.logical_and_expression_return logical_and_expression()
	{
		EnterRule_logical_and_expression();
		EnterRule("logical_and_expression", 4);
		TraceIn("logical_and_expression", 4);
		FleeParser.logical_and_expression_return retval = new FleeParser.logical_and_expression_return(this);
		retval.Start = (CommonToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		CommonToken AND5 = default(CommonToken);
		FleeParser.unary_not_expression_return e = default(FleeParser.unary_not_expression_return);

		CommonTree AND5_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "logical_and_expression");
		DebugLocation(47, 1);
		try
		{
			// C:\\Users\\Alexandr\\Sources\\Repos\\Expressions\\Expressions\\Flee\\Flee.g:48:2: (e= unary_not_expression ( AND e= unary_not_expression )* )
			DebugEnterAlt(1);
			// C:\\Users\\Alexandr\\Sources\\Repos\\Expressions\\Expressions\\Flee\\Flee.g:48:4: e= unary_not_expression ( AND e= unary_not_expression )*
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(48, 5);
			PushFollow(Follow._unary_not_expression_in_logical_and_expression198);
			e=unary_not_expression();
			PopFollow();

			adaptor.AddChild(root_0, e.Tree);
			DebugLocation(48, 27);
			 retval.value = (e!=null?e.value:default(IAstNode)); 
			DebugLocation(49, 3);
			// C:\\Users\\Alexandr\\Sources\\Repos\\Expressions\\Expressions\\Flee\\Flee.g:49:3: ( AND e= unary_not_expression )*
			try { DebugEnterSubRule(3);
			while (true)
			{
				int alt3=2;
				try { DebugEnterDecision(3, false);
				int LA3_1 = input.LA(1);

				if ((LA3_1==AND))
				{
					alt3 = 1;
				}


				} finally { DebugExitDecision(3); }
				switch ( alt3 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\Alexandr\\Sources\\Repos\\Expressions\\Expressions\\Flee\\Flee.g:49:5: AND e= unary_not_expression
					{
					DebugLocation(49, 5);
					AND5=(CommonToken)Match(input,AND,Follow._AND_in_logical_and_expression206); 
					AND5_tree = (CommonTree)adaptor.Create(AND5);
					adaptor.AddChild(root_0, AND5_tree);
					DebugLocation(49, 10);
					PushFollow(Follow._unary_not_expression_in_logical_and_expression210);
					e=unary_not_expression();
					PopFollow();

					adaptor.AddChild(root_0, e.Tree);
					DebugLocation(50, 5);
					 retval.value = new BinaryExpression(retval.value, (e!=null?e.value:default(IAstNode)), ExpressionType.And); 

					}
					break;

				default:
					goto loop3;
				}
			}

			loop3:
				;

			} finally { DebugExitSubRule(3); }


			}

			retval.Stop = (CommonToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}

		    catch (RecognitionException) 
		    {
		        throw;
		    }

		finally
		{
			TraceOut("logical_and_expression", 4);
			LeaveRule("logical_and_expression", 4);
			LeaveRule_logical_and_expression();
		}
		DebugLocation(52, 1);
		} finally { DebugExitRule(GrammarFileName, "logical_and_expression"); }
		return retval;

	}
	// $ANTLR end "logical_and_expression"

	private sealed partial class unary_not_expression_return : AstParserRuleReturnScope<CommonTree, CommonToken>
	{
		public IAstNode value;
		public unary_not_expression_return(FleeParser grammar) {OnCreated(grammar);}
		partial void OnCreated(FleeParser grammar);
	}

	partial void EnterRule_unary_not_expression();
	partial void LeaveRule_unary_not_expression();
	// $ANTLR start "unary_not_expression"
	// C:\\Users\\Alexandr\\Sources\\Repos\\Expressions\\Expressions\\Flee\\Flee.g:54:1: unary_not_expression returns [IAstNode value] : (e= equality_expression | NOT u= unary_not_expression );
	[GrammarRule("unary_not_expression")]
	private FleeParser.unary_not_expression_return unary_not_expression()
	{
		EnterRule_unary_not_expression();
		EnterRule("unary_not_expression", 5);
		TraceIn("unary_not_expression", 5);
		FleeParser.unary_not_expression_return retval = new FleeParser.unary_not_expression_return(this);
		retval.Start = (CommonToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		CommonToken NOT6 = default(CommonToken);
		FleeParser.equality_expression_return e = default(FleeParser.equality_expression_return);
		FleeParser.unary_not_expression_return u = default(FleeParser.unary_not_expression_return);

		CommonTree NOT6_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "unary_not_expression");
		DebugLocation(54, 1);
		try
		{
			// C:\\Users\\Alexandr\\Sources\\Repos\\Expressions\\Expressions\\Flee\\Flee.g:55:2: (e= equality_expression | NOT u= unary_not_expression )
			int alt4=2;
			try { DebugEnterDecision(4, false);
			int LA4_1 = input.LA(1);

			if (((LA4_1>=CAST && LA4_1<=DECIMAL_LITERAL)||(LA4_1>=FALSE && LA4_1<=FLOATING_POINT_LITERAL)||LA4_1==HEX_LITERAL||(LA4_1>=IDENTIFIER && LA4_1<=IF)||LA4_1==NULL||(LA4_1>=STRING_LITERAL && LA4_1<=TRUE)||LA4_1==33||LA4_1==36||LA4_1==38))
			{
				alt4 = 1;
			}
			else if ((LA4_1==NOT))
			{
				alt4 = 2;
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 4, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(4); }
			switch (alt4)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\Alexandr\\Sources\\Repos\\Expressions\\Expressions\\Flee\\Flee.g:55:4: e= equality_expression
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(55, 5);
				PushFollow(Follow._equality_expression_in_unary_not_expression238);
				e=equality_expression();
				PopFollow();

				adaptor.AddChild(root_0, e.Tree);
				DebugLocation(55, 26);
				 retval.value = (e!=null?e.value:default(IAstNode)); 

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\Users\\Alexandr\\Sources\\Repos\\Expressions\\Expressions\\Flee\\Flee.g:56:4: NOT u= unary_not_expression
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(56, 4);
				NOT6=(CommonToken)Match(input,NOT,Follow._NOT_in_unary_not_expression245); 
				NOT6_tree = (CommonTree)adaptor.Create(NOT6);
				adaptor.AddChild(root_0, NOT6_tree);
				DebugLocation(56, 9);
				PushFollow(Follow._unary_not_expression_in_unary_not_expression249);
				u=unary_not_expression();
				PopFollow();

				adaptor.AddChild(root_0, u.Tree);
				DebugLocation(56, 31);
				 retval.value = new UnaryExpression((u!=null?u.value:default(IAstNode)), ExpressionType.Not); 

				}
				break;

			}
			retval.Stop = (CommonToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}

		    catch (RecognitionException) 
		    {
		        throw;
		    }

		finally
		{
			TraceOut("unary_not_expression", 5);
			LeaveRule("unary_not_expression", 5);
			LeaveRule_unary_not_expression();
		}
		DebugLocation(57, 1);
		} finally { DebugExitRule(GrammarFileName, "unary_not_expression"); }
		return retval;

	}
	// $ANTLR end "unary_not_expression"

	private sealed partial class equality_expression_return : AstParserRuleReturnScope<CommonTree, CommonToken>
	{
		public IAstNode value;
		public equality_expression_return(FleeParser grammar) {OnCreated(grammar);}
		partial void OnCreated(FleeParser grammar);
	}

	partial void EnterRule_equality_expression();
	partial void LeaveRule_equality_expression();
	// $ANTLR start "equality_expression"
	// C:\\Users\\Alexandr\\Sources\\Repos\\Expressions\\Expressions\\Flee\\Flee.g:59:1: equality_expression returns [IAstNode value] : e= in_expression ( ( '=' e= in_expression | '<>' e= in_expression ) )* ;
	[GrammarRule("equality_expression")]
	private FleeParser.equality_expression_return equality_expression()
	{
		EnterRule_equality_expression();
		EnterRule("equality_expression", 6);
		TraceIn("equality_expression", 6);
		FleeParser.equality_expression_return retval = new FleeParser.equality_expression_return(this);
		retval.Start = (CommonToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		CommonToken char_literal7 = default(CommonToken);
		CommonToken string_literal8 = default(CommonToken);
		FleeParser.in_expression_return e = default(FleeParser.in_expression_return);

		CommonTree char_literal7_tree = default(CommonTree);
		CommonTree string_literal8_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "equality_expression");
		DebugLocation(59, 1);
		try
		{
			// C:\\Users\\Alexandr\\Sources\\Repos\\Expressions\\Expressions\\Flee\\Flee.g:60:2: (e= in_expression ( ( '=' e= in_expression | '<>' e= in_expression ) )* )
			DebugEnterAlt(1);
			// C:\\Users\\Alexandr\\Sources\\Repos\\Expressions\\Expressions\\Flee\\Flee.g:60:4: e= in_expression ( ( '=' e= in_expression | '<>' e= in_expression ) )*
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(60, 5);
			PushFollow(Follow._in_expression_in_equality_expression268);
			e=in_expression();
			PopFollow();

			adaptor.AddChild(root_0, e.Tree);
			DebugLocation(60, 20);
			 retval.value = (e!=null?e.value:default(IAstNode)); 
			DebugLocation(61, 3);
			// C:\\Users\\Alexandr\\Sources\\Repos\\Expressions\\Expressions\\Flee\\Flee.g:61:3: ( ( '=' e= in_expression | '<>' e= in_expression ) )*
			try { DebugEnterSubRule(6);
			while (true)
			{
				int alt6=2;
				try { DebugEnterDecision(6, false);
				int LA6_1 = input.LA(1);

				if (((LA6_1>=43 && LA6_1<=44)))
				{
					alt6 = 1;
				}


				} finally { DebugExitDecision(6); }
				switch ( alt6 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\Alexandr\\Sources\\Repos\\Expressions\\Expressions\\Flee\\Flee.g:62:4: ( '=' e= in_expression | '<>' e= in_expression )
					{
					DebugLocation(62, 4);
					// C:\\Users\\Alexandr\\Sources\\Repos\\Expressions\\Expressions\\Flee\\Flee.g:62:4: ( '=' e= in_expression | '<>' e= in_expression )
					int alt5=2;
					try { DebugEnterSubRule(5);
					try { DebugEnterDecision(5, false);
					int LA5_1 = input.LA(1);

					if ((LA5_1==44))
					{
						alt5 = 1;
					}
					else if ((LA5_1==43))
					{
						alt5 = 2;
					}
					else
					{
						NoViableAltException nvae = new NoViableAltException("", 5, 0, input, 1);
						DebugRecognitionException(nvae);
						throw nvae;
					}
					} finally { DebugExitDecision(5); }
					switch (alt5)
					{
					case 1:
						DebugEnterAlt(1);
						// C:\\Users\\Alexandr\\Sources\\Repos\\Expressions\\Expressions\\Flee\\Flee.g:62:6: '=' e= in_expression
						{
						DebugLocation(62, 6);
						char_literal7=(CommonToken)Match(input,44,Follow._44_in_equality_expression281); 
						char_literal7_tree = (CommonTree)adaptor.Create(char_literal7);
						adaptor.AddChild(root_0, char_literal7_tree);
						DebugLocation(62, 11);
						PushFollow(Follow._in_expression_in_equality_expression285);
						e=in_expression();
						PopFollow();

						adaptor.AddChild(root_0, e.Tree);
						DebugLocation(62, 26);
						 retval.value = new BinaryExpression(retval.value, (e!=null?e.value:default(IAstNode)), ExpressionType.Equals); 

						}
						break;
					case 2:
						DebugEnterAlt(2);
						// C:\\Users\\Alexandr\\Sources\\Repos\\Expressions\\Expressions\\Flee\\Flee.g:63:6: '<>' e= in_expression
						{
						DebugLocation(63, 6);
						string_literal8=(CommonToken)Match(input,43,Follow._43_in_equality_expression294); 
						string_literal8_tree = (CommonTree)adaptor.Create(string_literal8);
						adaptor.AddChild(root_0, string_literal8_tree);
						DebugLocation(63, 12);
						PushFollow(Follow._in_expression_in_equality_expression298);
						e=in_expression();
						PopFollow();

						adaptor.AddChild(root_0, e.Tree);
						DebugLocation(63, 27);
						 retval.value = new BinaryExpression(retval.value, (e!=null?e.value:default(IAstNode)), ExpressionType.NotEquals); 

						}
						break;

					}
					} finally { DebugExitSubRule(5); }


					}
					break;

				default:
					goto loop6;
				}
			}

			loop6:
				;

			} finally { DebugExitSubRule(6); }


			}

			retval.Stop = (CommonToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}

		    catch (RecognitionException) 
		    {
		        throw;
		    }

		finally
		{
			TraceOut("equality_expression", 6);
			LeaveRule("equality_expression", 6);
			LeaveRule_equality_expression();
		}
		DebugLocation(66, 1);
		} finally { DebugExitRule(GrammarFileName, "equality_expression"); }
		return retval;

	}
	// $ANTLR end "equality_expression"

	private sealed partial class in_expression_return : AstParserRuleReturnScope<CommonTree, CommonToken>
	{
		public IAstNode value;
		public in_expression_return(FleeParser grammar) {OnCreated(grammar);}
		partial void OnCreated(FleeParser grammar);
	}

	partial void EnterRule_in_expression();
	partial void LeaveRule_in_expression();
	// $ANTLR start "in_expression"
	// C:\\Users\\Alexandr\\Sources\\Repos\\Expressions\\Expressions\\Flee\\Flee.g:68:1: in_expression returns [IAstNode value] : e= relational_expression ( IN ( IDENTIFIER | '(' l= argument_expression_list ')' ) )? ;
	[GrammarRule("in_expression")]
	private FleeParser.in_expression_return in_expression()
	{
		EnterRule_in_expression();
		EnterRule("in_expression", 7);
		TraceIn("in_expression", 7);
		FleeParser.in_expression_return retval = new FleeParser.in_expression_return(this);
		retval.Start = (CommonToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		CommonToken IN9 = default(CommonToken);
		CommonToken IDENTIFIER10 = default(CommonToken);
		CommonToken char_literal11 = default(CommonToken);
		CommonToken char_literal12 = default(CommonToken);
		FleeParser.relational_expression_return e = default(FleeParser.relational_expression_return);
		FleeParser.argument_expression_list_return l = default(FleeParser.argument_expression_list_return);

		CommonTree IN9_tree = default(CommonTree);
		CommonTree IDENTIFIER10_tree = default(CommonTree);
		CommonTree char_literal11_tree = default(CommonTree);
		CommonTree char_literal12_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "in_expression");
		DebugLocation(68, 1);
		try
		{
			// C:\\Users\\Alexandr\\Sources\\Repos\\Expressions\\Expressions\\Flee\\Flee.g:69:2: (e= relational_expression ( IN ( IDENTIFIER | '(' l= argument_expression_list ')' ) )? )
			DebugEnterAlt(1);
			// C:\\Users\\Alexandr\\Sources\\Repos\\Expressions\\Expressions\\Flee\\Flee.g:69:4: e= relational_expression ( IN ( IDENTIFIER | '(' l= argument_expression_list ')' ) )?
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(69, 5);
			PushFollow(Follow._relational_expression_in_in_expression327);
			e=relational_expression();
			PopFollow();

			adaptor.AddChild(root_0, e.Tree);
			DebugLocation(69, 28);
			 retval.value = (e!=null?e.value:default(IAstNode)); 
			DebugLocation(70, 3);
			// C:\\Users\\Alexandr\\Sources\\Repos\\Expressions\\Expressions\\Flee\\Flee.g:70:3: ( IN ( IDENTIFIER | '(' l= argument_expression_list ')' ) )?
			int alt8=2;
			try { DebugEnterSubRule(8);
			try { DebugEnterDecision(8, false);
			int LA8_1 = input.LA(1);

			if ((LA8_1==IN))
			{
				alt8 = 1;
			}
			} finally { DebugExitDecision(8); }
			switch (alt8)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\Alexandr\\Sources\\Repos\\Expressions\\Expressions\\Flee\\Flee.g:71:4: IN ( IDENTIFIER | '(' l= argument_expression_list ')' )
				{
				DebugLocation(71, 4);
				IN9=(CommonToken)Match(input,IN,Follow._IN_in_in_expression338); 
				IN9_tree = (CommonTree)adaptor.Create(IN9);
				adaptor.AddChild(root_0, IN9_tree);
				DebugLocation(72, 5);
				// C:\\Users\\Alexandr\\Sources\\Repos\\Expressions\\Expressions\\Flee\\Flee.g:72:5: ( IDENTIFIER | '(' l= argument_expression_list ')' )
				int alt7=2;
				try { DebugEnterSubRule(7);
				try { DebugEnterDecision(7, false);
				int LA7_1 = input.LA(1);

				if ((LA7_1==IDENTIFIER))
				{
					alt7 = 1;
				}
				else if ((LA7_1==33))
				{
					alt7 = 2;
				}
				else
				{
					NoViableAltException nvae = new NoViableAltException("", 7, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				} finally { DebugExitDecision(7); }
				switch (alt7)
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\Alexandr\\Sources\\Repos\\Expressions\\Expressions\\Flee\\Flee.g:72:7: IDENTIFIER
					{
					DebugLocation(72, 7);
					IDENTIFIER10=(CommonToken)Match(input,IDENTIFIER,Follow._IDENTIFIER_in_in_expression346); 
					IDENTIFIER10_tree = (CommonTree)adaptor.Create(IDENTIFIER10);
					adaptor.AddChild(root_0, IDENTIFIER10_tree);
					DebugLocation(72, 18);
					 retval.value = new BinaryExpression(retval.value, CreateIdentifier((IDENTIFIER10!=null?IDENTIFIER10.Text:null)), ExpressionType.In); 

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// C:\\Users\\Alexandr\\Sources\\Repos\\Expressions\\Expressions\\Flee\\Flee.g:73:7: '(' l= argument_expression_list ')'
					{
					DebugLocation(73, 7);
					char_literal11=(CommonToken)Match(input,33,Follow._33_in_in_expression356); 
					char_literal11_tree = (CommonTree)adaptor.Create(char_literal11);
					adaptor.AddChild(root_0, char_literal11_tree);
					DebugLocation(73, 12);
					PushFollow(Follow._argument_expression_list_in_in_expression360);
					l=argument_expression_list();
					PopFollow();

					adaptor.AddChild(root_0, l.Tree);
					DebugLocation(73, 38);
					char_literal12=(CommonToken)Match(input,34,Follow._34_in_in_expression362); 
					char_literal12_tree = (CommonTree)adaptor.Create(char_literal12);
					adaptor.AddChild(root_0, char_literal12_tree);
					DebugLocation(73, 42);
					 retval.value = new BinaryExpression(retval.value, (l!=null?l.value:default(AstNodeCollection)), ExpressionType.In); 

					}
					break;

				}
				} finally { DebugExitSubRule(7); }


				}
				break;

			}
			} finally { DebugExitSubRule(8); }


			}

			retval.Stop = (CommonToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}

		    catch (RecognitionException) 
		    {
		        throw;
		    }

		finally
		{
			TraceOut("in_expression", 7);
			LeaveRule("in_expression", 7);
			LeaveRule_in_expression();
		}
		DebugLocation(76, 1);
		} finally { DebugExitRule(GrammarFileName, "in_expression"); }
		return retval;

	}
	// $ANTLR end "in_expression"

	private sealed partial class relational_expression_return : AstParserRuleReturnScope<CommonTree, CommonToken>
	{
		public IAstNode value;
		public relational_expression_return(FleeParser grammar) {OnCreated(grammar);}
		partial void OnCreated(FleeParser grammar);
	}

	partial void EnterRule_relational_expression();
	partial void LeaveRule_relational_expression();
	// $ANTLR start "relational_expression"
	// C:\\Users\\Alexandr\\Sources\\Repos\\Expressions\\Expressions\\Flee\\Flee.g:78:1: relational_expression returns [IAstNode value] : e= shift_expression ( ( '<' e= shift_expression | '>' e= shift_expression | '<=' e= shift_expression | '>=' e= shift_expression ) )* ;
	[GrammarRule("relational_expression")]
	private FleeParser.relational_expression_return relational_expression()
	{
		EnterRule_relational_expression();
		EnterRule("relational_expression", 8);
		TraceIn("relational_expression", 8);
		FleeParser.relational_expression_return retval = new FleeParser.relational_expression_return(this);
		retval.Start = (CommonToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		CommonToken char_literal13 = default(CommonToken);
		CommonToken char_literal14 = default(CommonToken);
		CommonToken string_literal15 = default(CommonToken);
		CommonToken string_literal16 = default(CommonToken);
		FleeParser.shift_expression_return e = default(FleeParser.shift_expression_return);

		CommonTree char_literal13_tree = default(CommonTree);
		CommonTree char_literal14_tree = default(CommonTree);
		CommonTree string_literal15_tree = default(CommonTree);
		CommonTree string_literal16_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "relational_expression");
		DebugLocation(78, 1);
		try
		{
			// C:\\Users\\Alexandr\\Sources\\Repos\\Expressions\\Expressions\\Flee\\Flee.g:79:2: (e= shift_expression ( ( '<' e= shift_expression | '>' e= shift_expression | '<=' e= shift_expression | '>=' e= shift_expression ) )* )
			DebugEnterAlt(1);
			// C:\\Users\\Alexandr\\Sources\\Repos\\Expressions\\Expressions\\Flee\\Flee.g:79:4: e= shift_expression ( ( '<' e= shift_expression | '>' e= shift_expression | '<=' e= shift_expression | '>=' e= shift_expression ) )*
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(79, 5);
			PushFollow(Follow._shift_expression_in_relational_expression392);
			e=shift_expression();
			PopFollow();

			adaptor.AddChild(root_0, e.Tree);
			DebugLocation(79, 23);
			 retval.value = (e!=null?e.value:default(IAstNode)); 
			DebugLocation(80, 3);
			// C:\\Users\\Alexandr\\Sources\\Repos\\Expressions\\Expressions\\Flee\\Flee.g:80:3: ( ( '<' e= shift_expression | '>' e= shift_expression | '<=' e= shift_expression | '>=' e= shift_expression ) )*
			try { DebugEnterSubRule(10);
			while (true)
			{
				int alt10=2;
				try { DebugEnterDecision(10, false);
				int LA10_1 = input.LA(1);

				if ((LA10_1==40||LA10_1==42||(LA10_1>=45 && LA10_1<=46)))
				{
					alt10 = 1;
				}


				} finally { DebugExitDecision(10); }
				switch ( alt10 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\Alexandr\\Sources\\Repos\\Expressions\\Expressions\\Flee\\Flee.g:81:4: ( '<' e= shift_expression | '>' e= shift_expression | '<=' e= shift_expression | '>=' e= shift_expression )
					{
					DebugLocation(81, 4);
					// C:\\Users\\Alexandr\\Sources\\Repos\\Expressions\\Expressions\\Flee\\Flee.g:81:4: ( '<' e= shift_expression | '>' e= shift_expression | '<=' e= shift_expression | '>=' e= shift_expression )
					int alt9=4;
					try { DebugEnterSubRule(9);
					try { DebugEnterDecision(9, false);
					switch (input.LA(1))
					{
					case 40:
						{
						alt9 = 1;
						}
						break;
					case 45:
						{
						alt9 = 2;
						}
						break;
					case 42:
						{
						alt9 = 3;
						}
						break;
					case 46:
						{
						alt9 = 4;
						}
						break;
					default:
						{
							NoViableAltException nvae = new NoViableAltException("", 9, 0, input, 1);
							DebugRecognitionException(nvae);
							throw nvae;
						}
					}

					} finally { DebugExitDecision(9); }
					switch (alt9)
					{
					case 1:
						DebugEnterAlt(1);
						// C:\\Users\\Alexandr\\Sources\\Repos\\Expressions\\Expressions\\Flee\\Flee.g:81:6: '<' e= shift_expression
						{
						DebugLocation(81, 6);
						char_literal13=(CommonToken)Match(input,40,Follow._40_in_relational_expression405); 
						char_literal13_tree = (CommonTree)adaptor.Create(char_literal13);
						adaptor.AddChild(root_0, char_literal13_tree);
						DebugLocation(81, 11);
						PushFollow(Follow._shift_expression_in_relational_expression409);
						e=shift_expression();
						PopFollow();

						adaptor.AddChild(root_0, e.Tree);
						DebugLocation(81, 29);
						 retval.value = new BinaryExpression(retval.value, (e!=null?e.value:default(IAstNode)), ExpressionType.Less); 

						}
						break;
					case 2:
						DebugEnterAlt(2);
						// C:\\Users\\Alexandr\\Sources\\Repos\\Expressions\\Expressions\\Flee\\Flee.g:82:6: '>' e= shift_expression
						{
						DebugLocation(82, 6);
						char_literal14=(CommonToken)Match(input,45,Follow._45_in_relational_expression418); 
						char_literal14_tree = (CommonTree)adaptor.Create(char_literal14);
						adaptor.AddChild(root_0, char_literal14_tree);
						DebugLocation(82, 11);
						PushFollow(Follow._shift_expression_in_relational_expression422);
						e=shift_expression();
						PopFollow();

						adaptor.AddChild(root_0, e.Tree);
						DebugLocation(82, 29);
						 retval.value = new BinaryExpression(retval.value, (e!=null?e.value:default(IAstNode)), ExpressionType.Greater); 

						}
						break;
					case 3:
						DebugEnterAlt(3);
						// C:\\Users\\Alexandr\\Sources\\Repos\\Expressions\\Expressions\\Flee\\Flee.g:83:6: '<=' e= shift_expression
						{
						DebugLocation(83, 6);
						string_literal15=(CommonToken)Match(input,42,Follow._42_in_relational_expression431); 
						string_literal15_tree = (CommonTree)adaptor.Create(string_literal15);
						adaptor.AddChild(root_0, string_literal15_tree);
						DebugLocation(83, 12);
						PushFollow(Follow._shift_expression_in_relational_expression435);
						e=shift_expression();
						PopFollow();

						adaptor.AddChild(root_0, e.Tree);
						DebugLocation(83, 30);
						 retval.value = new BinaryExpression(retval.value, (e!=null?e.value:default(IAstNode)), ExpressionType.LessOrEquals); 

						}
						break;
					case 4:
						DebugEnterAlt(4);
						// C:\\Users\\Alexandr\\Sources\\Repos\\Expressions\\Expressions\\Flee\\Flee.g:84:6: '>=' e= shift_expression
						{
						DebugLocation(84, 6);
						string_literal16=(CommonToken)Match(input,46,Follow._46_in_relational_expression444); 
						string_literal16_tree = (CommonTree)adaptor.Create(string_literal16);
						adaptor.AddChild(root_0, string_literal16_tree);
						DebugLocation(84, 12);
						PushFollow(Follow._shift_expression_in_relational_expression448);
						e=shift_expression();
						PopFollow();

						adaptor.AddChild(root_0, e.Tree);
						DebugLocation(84, 30);
						 retval.value = new BinaryExpression(retval.value, (e!=null?e.value:default(IAstNode)), ExpressionType.GreaterOrEquals); 

						}
						break;

					}
					} finally { DebugExitSubRule(9); }


					}
					break;

				default:
					goto loop10;
				}
			}

			loop10:
				;

			} finally { DebugExitSubRule(10); }


			}

			retval.Stop = (CommonToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}

		    catch (RecognitionException) 
		    {
		        throw;
		    }

		finally
		{
			TraceOut("relational_expression", 8);
			LeaveRule("relational_expression", 8);
			LeaveRule_relational_expression();
		}
		DebugLocation(87, 1);
		} finally { DebugExitRule(GrammarFileName, "relational_expression"); }
		return retval;

	}
	// $ANTLR end "relational_expression"

	private sealed partial class shift_expression_return : AstParserRuleReturnScope<CommonTree, CommonToken>
	{
		public IAstNode value;
		public shift_expression_return(FleeParser grammar) {OnCreated(grammar);}
		partial void OnCreated(FleeParser grammar);
	}

	partial void EnterRule_shift_expression();
	partial void LeaveRule_shift_expression();
	// $ANTLR start "shift_expression"
	// C:\\Users\\Alexandr\\Sources\\Repos\\Expressions\\Expressions\\Flee\\Flee.g:89:1: shift_expression returns [IAstNode value] : e= additive_expression ( ( '<<' e= additive_expression | '>>' e= additive_expression ) )* ;
	[GrammarRule("shift_expression")]
	private FleeParser.shift_expression_return shift_expression()
	{
		EnterRule_shift_expression();
		EnterRule("shift_expression", 9);
		TraceIn("shift_expression", 9);
		FleeParser.shift_expression_return retval = new FleeParser.shift_expression_return(this);
		retval.Start = (CommonToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		CommonToken string_literal17 = default(CommonToken);
		CommonToken string_literal18 = default(CommonToken);
		FleeParser.additive_expression_return e = default(FleeParser.additive_expression_return);

		CommonTree string_literal17_tree = default(CommonTree);
		CommonTree string_literal18_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "shift_expression");
		DebugLocation(89, 1);
		try
		{
			// C:\\Users\\Alexandr\\Sources\\Repos\\Expressions\\Expressions\\Flee\\Flee.g:90:2: (e= additive_expression ( ( '<<' e= additive_expression | '>>' e= additive_expression ) )* )
			DebugEnterAlt(1);
			// C:\\Users\\Alexandr\\Sources\\Repos\\Expressions\\Expressions\\Flee\\Flee.g:90:4: e= additive_expression ( ( '<<' e= additive_expression | '>>' e= additive_expression ) )*
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(90, 5);
			PushFollow(Follow._additive_expression_in_shift_expression477);
			e=additive_expression();
			PopFollow();

			adaptor.AddChild(root_0, e.Tree);
			DebugLocation(90, 26);
			 retval.value = (e!=null?e.value:default(IAstNode)); 
			DebugLocation(91, 3);
			// C:\\Users\\Alexandr\\Sources\\Repos\\Expressions\\Expressions\\Flee\\Flee.g:91:3: ( ( '<<' e= additive_expression | '>>' e= additive_expression ) )*
			try { DebugEnterSubRule(12);
			while (true)
			{
				int alt12=2;
				try { DebugEnterDecision(12, false);
				int LA12_1 = input.LA(1);

				if ((LA12_1==41||LA12_1==47))
				{
					alt12 = 1;
				}


				} finally { DebugExitDecision(12); }
				switch ( alt12 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\Alexandr\\Sources\\Repos\\Expressions\\Expressions\\Flee\\Flee.g:92:4: ( '<<' e= additive_expression | '>>' e= additive_expression )
					{
					DebugLocation(92, 4);
					// C:\\Users\\Alexandr\\Sources\\Repos\\Expressions\\Expressions\\Flee\\Flee.g:92:4: ( '<<' e= additive_expression | '>>' e= additive_expression )
					int alt11=2;
					try { DebugEnterSubRule(11);
					try { DebugEnterDecision(11, false);
					int LA11_1 = input.LA(1);

					if ((LA11_1==41))
					{
						alt11 = 1;
					}
					else if ((LA11_1==47))
					{
						alt11 = 2;
					}
					else
					{
						NoViableAltException nvae = new NoViableAltException("", 11, 0, input, 1);
						DebugRecognitionException(nvae);
						throw nvae;
					}
					} finally { DebugExitDecision(11); }
					switch (alt11)
					{
					case 1:
						DebugEnterAlt(1);
						// C:\\Users\\Alexandr\\Sources\\Repos\\Expressions\\Expressions\\Flee\\Flee.g:92:6: '<<' e= additive_expression
						{
						DebugLocation(92, 6);
						string_literal17=(CommonToken)Match(input,41,Follow._41_in_shift_expression490); 
						string_literal17_tree = (CommonTree)adaptor.Create(string_literal17);
						adaptor.AddChild(root_0, string_literal17_tree);
						DebugLocation(92, 12);
						PushFollow(Follow._additive_expression_in_shift_expression494);
						e=additive_expression();
						PopFollow();

						adaptor.AddChild(root_0, e.Tree);
						DebugLocation(92, 33);
						 retval.value = new BinaryExpression(retval.value, (e!=null?e.value:default(IAstNode)), ExpressionType.ShiftLeft); 

						}
						break;
					case 2:
						DebugEnterAlt(2);
						// C:\\Users\\Alexandr\\Sources\\Repos\\Expressions\\Expressions\\Flee\\Flee.g:93:6: '>>' e= additive_expression
						{
						DebugLocation(93, 6);
						string_literal18=(CommonToken)Match(input,47,Follow._47_in_shift_expression503); 
						string_literal18_tree = (CommonTree)adaptor.Create(string_literal18);
						adaptor.AddChild(root_0, string_literal18_tree);
						DebugLocation(93, 12);
						PushFollow(Follow._additive_expression_in_shift_expression507);
						e=additive_expression();
						PopFollow();

						adaptor.AddChild(root_0, e.Tree);
						DebugLocation(93, 33);
						 retval.value = new BinaryExpression(retval.value, (e!=null?e.value:default(IAstNode)), ExpressionType.ShiftRight); 

						}
						break;

					}
					} finally { DebugExitSubRule(11); }


					}
					break;

				default:
					goto loop12;
				}
			}

			loop12:
				;

			} finally { DebugExitSubRule(12); }


			}

			retval.Stop = (CommonToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}

		    catch (RecognitionException) 
		    {
		        throw;
		    }

		finally
		{
			TraceOut("shift_expression", 9);
			LeaveRule("shift_expression", 9);
			LeaveRule_shift_expression();
		}
		DebugLocation(96, 1);
		} finally { DebugExitRule(GrammarFileName, "shift_expression"); }
		return retval;

	}
	// $ANTLR end "shift_expression"

	private sealed partial class additive_expression_return : AstParserRuleReturnScope<CommonTree, CommonToken>
	{
		public IAstNode value;
		public additive_expression_return(FleeParser grammar) {OnCreated(grammar);}
		partial void OnCreated(FleeParser grammar);
	}

	partial void EnterRule_additive_expression();
	partial void LeaveRule_additive_expression();
	// $ANTLR start "additive_expression"
	// C:\\Users\\Alexandr\\Sources\\Repos\\Expressions\\Expressions\\Flee\\Flee.g:98:1: additive_expression returns [IAstNode value] : e= multiplicative_expression ( '+' e= multiplicative_expression | '-' e= multiplicative_expression )* ;
	[GrammarRule("additive_expression")]
	private FleeParser.additive_expression_return additive_expression()
	{
		EnterRule_additive_expression();
		EnterRule("additive_expression", 10);
		TraceIn("additive_expression", 10);
		FleeParser.additive_expression_return retval = new FleeParser.additive_expression_return(this);
		retval.Start = (CommonToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		CommonToken char_literal19 = default(CommonToken);
		CommonToken char_literal20 = default(CommonToken);
		FleeParser.multiplicative_expression_return e = default(FleeParser.multiplicative_expression_return);

		CommonTree char_literal19_tree = default(CommonTree);
		CommonTree char_literal20_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "additive_expression");
		DebugLocation(98, 1);
		try
		{
			// C:\\Users\\Alexandr\\Sources\\Repos\\Expressions\\Expressions\\Flee\\Flee.g:99:2: (e= multiplicative_expression ( '+' e= multiplicative_expression | '-' e= multiplicative_expression )* )
			DebugEnterAlt(1);
			// C:\\Users\\Alexandr\\Sources\\Repos\\Expressions\\Expressions\\Flee\\Flee.g:99:4: e= multiplicative_expression ( '+' e= multiplicative_expression | '-' e= multiplicative_expression )*
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(99, 5);
			PushFollow(Follow._multiplicative_expression_in_additive_expression536);
			e=multiplicative_expression();
			PopFollow();

			adaptor.AddChild(root_0, e.Tree);
			DebugLocation(99, 32);
			 retval.value = (e!=null?e.value:default(IAstNode)); 
			DebugLocation(100, 3);
			// C:\\Users\\Alexandr\\Sources\\Repos\\Expressions\\Expressions\\Flee\\Flee.g:100:3: ( '+' e= multiplicative_expression | '-' e= multiplicative_expression )*
			try { DebugEnterSubRule(13);
			while (true)
			{
				int alt13=3;
				try { DebugEnterDecision(13, false);
				int LA13_1 = input.LA(1);

				if ((LA13_1==36))
				{
					alt13 = 1;
				}
				else if ((LA13_1==38))
				{
					alt13 = 2;
				}


				} finally { DebugExitDecision(13); }
				switch ( alt13 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\Alexandr\\Sources\\Repos\\Expressions\\Expressions\\Flee\\Flee.g:100:5: '+' e= multiplicative_expression
					{
					DebugLocation(100, 5);
					char_literal19=(CommonToken)Match(input,36,Follow._36_in_additive_expression544); 
					char_literal19_tree = (CommonTree)adaptor.Create(char_literal19);
					adaptor.AddChild(root_0, char_literal19_tree);
					DebugLocation(100, 10);
					PushFollow(Follow._multiplicative_expression_in_additive_expression548);
					e=multiplicative_expression();
					PopFollow();

					adaptor.AddChild(root_0, e.Tree);
					DebugLocation(100, 37);
					 retval.value = new BinaryExpression(retval.value, (e!=null?e.value:default(IAstNode)), ExpressionType.Add); 

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// C:\\Users\\Alexandr\\Sources\\Repos\\Expressions\\Expressions\\Flee\\Flee.g:101:5: '-' e= multiplicative_expression
					{
					DebugLocation(101, 5);
					char_literal20=(CommonToken)Match(input,38,Follow._38_in_additive_expression556); 
					char_literal20_tree = (CommonTree)adaptor.Create(char_literal20);
					adaptor.AddChild(root_0, char_literal20_tree);
					DebugLocation(101, 10);
					PushFollow(Follow._multiplicative_expression_in_additive_expression560);
					e=multiplicative_expression();
					PopFollow();

					adaptor.AddChild(root_0, e.Tree);
					DebugLocation(101, 37);
					 retval.value = new BinaryExpression(retval.value, (e!=null?e.value:default(IAstNode)), ExpressionType.Subtract); 

					}
					break;

				default:
					goto loop13;
				}
			}

			loop13:
				;

			} finally { DebugExitSubRule(13); }


			}

			retval.Stop = (CommonToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}

		    catch (RecognitionException) 
		    {
		        throw;
		    }

		finally
		{
			TraceOut("additive_expression", 10);
			LeaveRule("additive_expression", 10);
			LeaveRule_additive_expression();
		}
		DebugLocation(103, 1);
		} finally { DebugExitRule(GrammarFileName, "additive_expression"); }
		return retval;

	}
	// $ANTLR end "additive_expression"

	private sealed partial class multiplicative_expression_return : AstParserRuleReturnScope<CommonTree, CommonToken>
	{
		public IAstNode value;
		public multiplicative_expression_return(FleeParser grammar) {OnCreated(grammar);}
		partial void OnCreated(FleeParser grammar);
	}

	partial void EnterRule_multiplicative_expression();
	partial void LeaveRule_multiplicative_expression();
	// $ANTLR start "multiplicative_expression"
	// C:\\Users\\Alexandr\\Sources\\Repos\\Expressions\\Expressions\\Flee\\Flee.g:105:1: multiplicative_expression returns [IAstNode value] : e= power_expression ( '*' e= power_expression | '/' e= power_expression | '%' e= power_expression )* ;
	[GrammarRule("multiplicative_expression")]
	private FleeParser.multiplicative_expression_return multiplicative_expression()
	{
		EnterRule_multiplicative_expression();
		EnterRule("multiplicative_expression", 11);
		TraceIn("multiplicative_expression", 11);
		FleeParser.multiplicative_expression_return retval = new FleeParser.multiplicative_expression_return(this);
		retval.Start = (CommonToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		CommonToken char_literal21 = default(CommonToken);
		CommonToken char_literal22 = default(CommonToken);
		CommonToken char_literal23 = default(CommonToken);
		FleeParser.power_expression_return e = default(FleeParser.power_expression_return);

		CommonTree char_literal21_tree = default(CommonTree);
		CommonTree char_literal22_tree = default(CommonTree);
		CommonTree char_literal23_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "multiplicative_expression");
		DebugLocation(105, 1);
		try
		{
			// C:\\Users\\Alexandr\\Sources\\Repos\\Expressions\\Expressions\\Flee\\Flee.g:106:2: (e= power_expression ( '*' e= power_expression | '/' e= power_expression | '%' e= power_expression )* )
			DebugEnterAlt(1);
			// C:\\Users\\Alexandr\\Sources\\Repos\\Expressions\\Expressions\\Flee\\Flee.g:106:4: e= power_expression ( '*' e= power_expression | '/' e= power_expression | '%' e= power_expression )*
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(106, 5);
			PushFollow(Follow._power_expression_in_multiplicative_expression584);
			e=power_expression();
			PopFollow();

			adaptor.AddChild(root_0, e.Tree);
			DebugLocation(106, 23);
			 retval.value = (e!=null?e.value:default(IAstNode)); 
			DebugLocation(107, 3);
			// C:\\Users\\Alexandr\\Sources\\Repos\\Expressions\\Expressions\\Flee\\Flee.g:107:3: ( '*' e= power_expression | '/' e= power_expression | '%' e= power_expression )*
			try { DebugEnterSubRule(14);
			while (true)
			{
				int alt14=4;
				try { DebugEnterDecision(14, false);
				switch (input.LA(1))
				{
				case 35:
					{
					alt14 = 1;
					}
					break;
				case 39:
					{
					alt14 = 2;
					}
					break;
				case 32:
					{
					alt14 = 3;
					}
					break;
				}

				} finally { DebugExitDecision(14); }
				switch ( alt14 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\Alexandr\\Sources\\Repos\\Expressions\\Expressions\\Flee\\Flee.g:107:5: '*' e= power_expression
					{
					DebugLocation(107, 5);
					char_literal21=(CommonToken)Match(input,35,Follow._35_in_multiplicative_expression592); 
					char_literal21_tree = (CommonTree)adaptor.Create(char_literal21);
					adaptor.AddChild(root_0, char_literal21_tree);
					DebugLocation(107, 10);
					PushFollow(Follow._power_expression_in_multiplicative_expression596);
					e=power_expression();
					PopFollow();

					adaptor.AddChild(root_0, e.Tree);
					DebugLocation(107, 28);
					 retval.value = new BinaryExpression(retval.value, (e!=null?e.value:default(IAstNode)), ExpressionType.Multiply); 

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// C:\\Users\\Alexandr\\Sources\\Repos\\Expressions\\Expressions\\Flee\\Flee.g:108:5: '/' e= power_expression
					{
					DebugLocation(108, 5);
					char_literal22=(CommonToken)Match(input,39,Follow._39_in_multiplicative_expression604); 
					char_literal22_tree = (CommonTree)adaptor.Create(char_literal22);
					adaptor.AddChild(root_0, char_literal22_tree);
					DebugLocation(108, 10);
					PushFollow(Follow._power_expression_in_multiplicative_expression608);
					e=power_expression();
					PopFollow();

					adaptor.AddChild(root_0, e.Tree);
					DebugLocation(108, 28);
					 retval.value = new BinaryExpression(retval.value, (e!=null?e.value:default(IAstNode)), ExpressionType.Divide); 

					}
					break;
				case 3:
					DebugEnterAlt(3);
					// C:\\Users\\Alexandr\\Sources\\Repos\\Expressions\\Expressions\\Flee\\Flee.g:109:5: '%' e= power_expression
					{
					DebugLocation(109, 5);
					char_literal23=(CommonToken)Match(input,32,Follow._32_in_multiplicative_expression616); 
					char_literal23_tree = (CommonTree)adaptor.Create(char_literal23);
					adaptor.AddChild(root_0, char_literal23_tree);
					DebugLocation(109, 10);
					PushFollow(Follow._power_expression_in_multiplicative_expression620);
					e=power_expression();
					PopFollow();

					adaptor.AddChild(root_0, e.Tree);
					DebugLocation(109, 28);
					 retval.value = new BinaryExpression(retval.value, (e!=null?e.value:default(IAstNode)), ExpressionType.Modulo); 

					}
					break;

				default:
					goto loop14;
				}
			}

			loop14:
				;

			} finally { DebugExitSubRule(14); }


			}

			retval.Stop = (CommonToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}

		    catch (RecognitionException) 
		    {
		        throw;
		    }

		finally
		{
			TraceOut("multiplicative_expression", 11);
			LeaveRule("multiplicative_expression", 11);
			LeaveRule_multiplicative_expression();
		}
		DebugLocation(111, 1);
		} finally { DebugExitRule(GrammarFileName, "multiplicative_expression"); }
		return retval;

	}
	// $ANTLR end "multiplicative_expression"

	private sealed partial class power_expression_return : AstParserRuleReturnScope<CommonTree, CommonToken>
	{
		public IAstNode value;
		public power_expression_return(FleeParser grammar) {OnCreated(grammar);}
		partial void OnCreated(FleeParser grammar);
	}

	partial void EnterRule_power_expression();
	partial void LeaveRule_power_expression();
	// $ANTLR start "power_expression"
	// C:\\Users\\Alexandr\\Sources\\Repos\\Expressions\\Expressions\\Flee\\Flee.g:113:1: power_expression returns [IAstNode value] : e= cast_expression ( '^' e= cast_expression )* ;
	[GrammarRule("power_expression")]
	private FleeParser.power_expression_return power_expression()
	{
		EnterRule_power_expression();
		EnterRule("power_expression", 12);
		TraceIn("power_expression", 12);
		FleeParser.power_expression_return retval = new FleeParser.power_expression_return(this);
		retval.Start = (CommonToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		CommonToken char_literal24 = default(CommonToken);
		FleeParser.cast_expression_return e = default(FleeParser.cast_expression_return);

		CommonTree char_literal24_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "power_expression");
		DebugLocation(113, 1);
		try
		{
			// C:\\Users\\Alexandr\\Sources\\Repos\\Expressions\\Expressions\\Flee\\Flee.g:114:2: (e= cast_expression ( '^' e= cast_expression )* )
			DebugEnterAlt(1);
			// C:\\Users\\Alexandr\\Sources\\Repos\\Expressions\\Expressions\\Flee\\Flee.g:114:4: e= cast_expression ( '^' e= cast_expression )*
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(114, 5);
			PushFollow(Follow._cast_expression_in_power_expression644);
			e=cast_expression();
			PopFollow();

			adaptor.AddChild(root_0, e.Tree);
			DebugLocation(114, 22);
			 retval.value = (e!=null?e.value:default(IAstNode)); 
			DebugLocation(115, 3);
			// C:\\Users\\Alexandr\\Sources\\Repos\\Expressions\\Expressions\\Flee\\Flee.g:115:3: ( '^' e= cast_expression )*
			try { DebugEnterSubRule(15);
			while (true)
			{
				int alt15=2;
				try { DebugEnterDecision(15, false);
				int LA15_1 = input.LA(1);

				if ((LA15_1==50))
				{
					alt15 = 1;
				}


				} finally { DebugExitDecision(15); }
				switch ( alt15 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\Alexandr\\Sources\\Repos\\Expressions\\Expressions\\Flee\\Flee.g:115:5: '^' e= cast_expression
					{
					DebugLocation(115, 5);
					char_literal24=(CommonToken)Match(input,50,Follow._50_in_power_expression652); 
					char_literal24_tree = (CommonTree)adaptor.Create(char_literal24);
					adaptor.AddChild(root_0, char_literal24_tree);
					DebugLocation(115, 10);
					PushFollow(Follow._cast_expression_in_power_expression656);
					e=cast_expression();
					PopFollow();

					adaptor.AddChild(root_0, e.Tree);
					DebugLocation(115, 27);
					 retval.value = new BinaryExpression(retval.value, (e!=null?e.value:default(IAstNode)), ExpressionType.Power); 

					}
					break;

				default:
					goto loop15;
				}
			}

			loop15:
				;

			} finally { DebugExitSubRule(15); }


			}

			retval.Stop = (CommonToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}

		    catch (RecognitionException) 
		    {
		        throw;
		    }

		finally
		{
			TraceOut("power_expression", 12);
			LeaveRule("power_expression", 12);
			LeaveRule_power_expression();
		}
		DebugLocation(117, 1);
		} finally { DebugExitRule(GrammarFileName, "power_expression"); }
		return retval;

	}
	// $ANTLR end "power_expression"

	private sealed partial class cast_expression_return : AstParserRuleReturnScope<CommonTree, CommonToken>
	{
		public IAstNode value;
		public cast_expression_return(FleeParser grammar) {OnCreated(grammar);}
		partial void OnCreated(FleeParser grammar);
	}

	partial void EnterRule_cast_expression();
	partial void LeaveRule_cast_expression();
	// $ANTLR start "cast_expression"
	// C:\\Users\\Alexandr\\Sources\\Repos\\Expressions\\Expressions\\Flee\\Flee.g:119:1: cast_expression returns [IAstNode value] : ( CAST '(' e= expression ',' t= type_expression ')' |u= if_expression );
	[GrammarRule("cast_expression")]
	private FleeParser.cast_expression_return cast_expression()
	{
		EnterRule_cast_expression();
		EnterRule("cast_expression", 13);
		TraceIn("cast_expression", 13);
		FleeParser.cast_expression_return retval = new FleeParser.cast_expression_return(this);
		retval.Start = (CommonToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		CommonToken CAST25 = default(CommonToken);
		CommonToken char_literal26 = default(CommonToken);
		CommonToken char_literal27 = default(CommonToken);
		CommonToken char_literal28 = default(CommonToken);
		FleeParser.expression_return e = default(FleeParser.expression_return);
		FleeParser.type_expression_return t = default(FleeParser.type_expression_return);
		FleeParser.if_expression_return u = default(FleeParser.if_expression_return);

		CommonTree CAST25_tree = default(CommonTree);
		CommonTree char_literal26_tree = default(CommonTree);
		CommonTree char_literal27_tree = default(CommonTree);
		CommonTree char_literal28_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "cast_expression");
		DebugLocation(119, 1);
		try
		{
			// C:\\Users\\Alexandr\\Sources\\Repos\\Expressions\\Expressions\\Flee\\Flee.g:120:2: ( CAST '(' e= expression ',' t= type_expression ')' |u= if_expression )
			int alt16=2;
			try { DebugEnterDecision(16, false);
			int LA16_1 = input.LA(1);

			if ((LA16_1==CAST))
			{
				alt16 = 1;
			}
			else if (((LA16_1>=CHARACTER_LITERAL && LA16_1<=DECIMAL_LITERAL)||(LA16_1>=FALSE && LA16_1<=FLOATING_POINT_LITERAL)||LA16_1==HEX_LITERAL||(LA16_1>=IDENTIFIER && LA16_1<=IF)||LA16_1==NULL||(LA16_1>=STRING_LITERAL && LA16_1<=TRUE)||LA16_1==33||LA16_1==36||LA16_1==38))
			{
				alt16 = 2;
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 16, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(16); }
			switch (alt16)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\Alexandr\\Sources\\Repos\\Expressions\\Expressions\\Flee\\Flee.g:120:4: CAST '(' e= expression ',' t= type_expression ')'
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(120, 4);
				CAST25=(CommonToken)Match(input,CAST,Follow._CAST_in_cast_expression678); 
				CAST25_tree = (CommonTree)adaptor.Create(CAST25);
				adaptor.AddChild(root_0, CAST25_tree);
				DebugLocation(120, 9);
				char_literal26=(CommonToken)Match(input,33,Follow._33_in_cast_expression680); 
				char_literal26_tree = (CommonTree)adaptor.Create(char_literal26);
				adaptor.AddChild(root_0, char_literal26_tree);
				DebugLocation(120, 14);
				PushFollow(Follow._expression_in_cast_expression684);
				e=expression();
				PopFollow();

				adaptor.AddChild(root_0, e.Tree);
				DebugLocation(120, 26);
				char_literal27=(CommonToken)Match(input,37,Follow._37_in_cast_expression686); 
				char_literal27_tree = (CommonTree)adaptor.Create(char_literal27);
				adaptor.AddChild(root_0, char_literal27_tree);
				DebugLocation(120, 31);
				PushFollow(Follow._type_expression_in_cast_expression690);
				t=type_expression();
				PopFollow();

				adaptor.AddChild(root_0, t.Tree);
				DebugLocation(120, 48);
				char_literal28=(CommonToken)Match(input,34,Follow._34_in_cast_expression692); 
				char_literal28_tree = (CommonTree)adaptor.Create(char_literal28);
				adaptor.AddChild(root_0, char_literal28_tree);
				DebugLocation(120, 52);
				 retval.value = new Cast((e!=null?e.value:default(IAstNode)), (t!=null?t.value:default(TypeIdentifier))); 

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\Users\\Alexandr\\Sources\\Repos\\Expressions\\Expressions\\Flee\\Flee.g:121:4: u= if_expression
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(121, 5);
				PushFollow(Follow._if_expression_in_cast_expression701);
				u=if_expression();
				PopFollow();

				adaptor.AddChild(root_0, u.Tree);
				DebugLocation(121, 20);
				 retval.value = (u!=null?u.value:default(IAstNode)); 

				}
				break;

			}
			retval.Stop = (CommonToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}

		    catch (RecognitionException) 
		    {
		        throw;
		    }

		finally
		{
			TraceOut("cast_expression", 13);
			LeaveRule("cast_expression", 13);
			LeaveRule_cast_expression();
		}
		DebugLocation(122, 1);
		} finally { DebugExitRule(GrammarFileName, "cast_expression"); }
		return retval;

	}
	// $ANTLR end "cast_expression"

	private sealed partial class type_expression_return : AstParserRuleReturnScope<CommonTree, CommonToken>
	{
		public TypeIdentifier value;
		public type_expression_return(FleeParser grammar) {OnCreated(grammar);}
		partial void OnCreated(FleeParser grammar);
	}

	partial void EnterRule_type_expression();
	partial void LeaveRule_type_expression();
	// $ANTLR start "type_expression"
	// C:\\Users\\Alexandr\\Sources\\Repos\\Expressions\\Expressions\\Flee\\Flee.g:124:1: type_expression returns [TypeIdentifier value] : e= type_identifier ( '[' ( ',' )* ']' )? ;
	[GrammarRule("type_expression")]
	private FleeParser.type_expression_return type_expression()
	{
		EnterRule_type_expression();
		EnterRule("type_expression", 14);
		TraceIn("type_expression", 14);
		FleeParser.type_expression_return retval = new FleeParser.type_expression_return(this);
		retval.Start = (CommonToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		CommonToken char_literal29 = default(CommonToken);
		CommonToken char_literal30 = default(CommonToken);
		CommonToken char_literal31 = default(CommonToken);
		FleeParser.type_identifier_return e = default(FleeParser.type_identifier_return);

		CommonTree char_literal29_tree = default(CommonTree);
		CommonTree char_literal30_tree = default(CommonTree);
		CommonTree char_literal31_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "type_expression");
		DebugLocation(124, 1);
		try
		{
			// C:\\Users\\Alexandr\\Sources\\Repos\\Expressions\\Expressions\\Flee\\Flee.g:125:2: (e= type_identifier ( '[' ( ',' )* ']' )? )
			DebugEnterAlt(1);
			// C:\\Users\\Alexandr\\Sources\\Repos\\Expressions\\Expressions\\Flee\\Flee.g:125:4: e= type_identifier ( '[' ( ',' )* ']' )?
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(125, 5);
			PushFollow(Follow._type_identifier_in_type_expression720);
			e=type_identifier();
			PopFollow();

			adaptor.AddChild(root_0, e.Tree);
			DebugLocation(125, 22);
			 retval.value = new TypeIdentifier((e!=null?e.value:default(string)), 0); 
			DebugLocation(126, 3);
			// C:\\Users\\Alexandr\\Sources\\Repos\\Expressions\\Expressions\\Flee\\Flee.g:126:3: ( '[' ( ',' )* ']' )?
			int alt18=2;
			try { DebugEnterSubRule(18);
			try { DebugEnterDecision(18, false);
			int LA18_1 = input.LA(1);

			if ((LA18_1==48))
			{
				alt18 = 1;
			}
			} finally { DebugExitDecision(18); }
			switch (alt18)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\Alexandr\\Sources\\Repos\\Expressions\\Expressions\\Flee\\Flee.g:127:4: '[' ( ',' )* ']'
				{
				DebugLocation(127, 4);
				char_literal29=(CommonToken)Match(input,48,Follow._48_in_type_expression731); 
				char_literal29_tree = (CommonTree)adaptor.Create(char_literal29);
				adaptor.AddChild(root_0, char_literal29_tree);
				DebugLocation(127, 8);
				 retval.value = new TypeIdentifier(retval.value.Name, 1); 
				DebugLocation(128, 5);
				// C:\\Users\\Alexandr\\Sources\\Repos\\Expressions\\Expressions\\Flee\\Flee.g:128:5: ( ',' )*
				try { DebugEnterSubRule(17);
				while (true)
				{
					int alt17=2;
					try { DebugEnterDecision(17, false);
					int LA17_1 = input.LA(1);

					if ((LA17_1==37))
					{
						alt17 = 1;
					}


					} finally { DebugExitDecision(17); }
					switch ( alt17 )
					{
					case 1:
						DebugEnterAlt(1);
						// C:\\Users\\Alexandr\\Sources\\Repos\\Expressions\\Expressions\\Flee\\Flee.g:128:7: ','
						{
						DebugLocation(128, 7);
						char_literal30=(CommonToken)Match(input,37,Follow._37_in_type_expression741); 
						char_literal30_tree = (CommonTree)adaptor.Create(char_literal30);
						adaptor.AddChild(root_0, char_literal30_tree);
						DebugLocation(128, 11);
						 retval.value = new TypeIdentifier(retval.value.Name, retval.value.ArrayIndex + 1); 

						}
						break;

					default:
						goto loop17;
					}
				}

				loop17:
					;

				} finally { DebugExitSubRule(17); }

				DebugLocation(130, 4);
				char_literal31=(CommonToken)Match(input,49,Follow._49_in_type_expression755); 
				char_literal31_tree = (CommonTree)adaptor.Create(char_literal31);
				adaptor.AddChild(root_0, char_literal31_tree);

				}
				break;

			}
			} finally { DebugExitSubRule(18); }


			}

			retval.Stop = (CommonToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}

		    catch (RecognitionException) 
		    {
		        throw;
		    }

		finally
		{
			TraceOut("type_expression", 14);
			LeaveRule("type_expression", 14);
			LeaveRule_type_expression();
		}
		DebugLocation(132, 1);
		} finally { DebugExitRule(GrammarFileName, "type_expression"); }
		return retval;

	}
	// $ANTLR end "type_expression"

	private sealed partial class type_identifier_return : AstParserRuleReturnScope<CommonTree, CommonToken>
	{
		public string value;
		public type_identifier_return(FleeParser grammar) {OnCreated(grammar);}
		partial void OnCreated(FleeParser grammar);
	}

	partial void EnterRule_type_identifier();
	partial void LeaveRule_type_identifier();
	// $ANTLR start "type_identifier"
	// C:\\Users\\Alexandr\\Sources\\Repos\\Expressions\\Expressions\\Flee\\Flee.g:134:1: type_identifier returns [string value] : e= IDENTIFIER ( DOT e= IDENTIFIER )* ;
	[GrammarRule("type_identifier")]
	private FleeParser.type_identifier_return type_identifier()
	{
		EnterRule_type_identifier();
		EnterRule("type_identifier", 15);
		TraceIn("type_identifier", 15);
		FleeParser.type_identifier_return retval = new FleeParser.type_identifier_return(this);
		retval.Start = (CommonToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		CommonToken e = default(CommonToken);
		CommonToken DOT32 = default(CommonToken);

		CommonTree e_tree = default(CommonTree);
		CommonTree DOT32_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "type_identifier");
		DebugLocation(134, 1);
		try
		{
			// C:\\Users\\Alexandr\\Sources\\Repos\\Expressions\\Expressions\\Flee\\Flee.g:135:2: (e= IDENTIFIER ( DOT e= IDENTIFIER )* )
			DebugEnterAlt(1);
			// C:\\Users\\Alexandr\\Sources\\Repos\\Expressions\\Expressions\\Flee\\Flee.g:135:4: e= IDENTIFIER ( DOT e= IDENTIFIER )*
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(135, 5);
			e=(CommonToken)Match(input,IDENTIFIER,Follow._IDENTIFIER_in_type_identifier777); 
			e_tree = (CommonTree)adaptor.Create(e);
			adaptor.AddChild(root_0, e_tree);
			DebugLocation(135, 17);
			 retval.value = (e!=null?e.Text:null); 
			DebugLocation(135, 39);
			// C:\\Users\\Alexandr\\Sources\\Repos\\Expressions\\Expressions\\Flee\\Flee.g:135:39: ( DOT e= IDENTIFIER )*
			try { DebugEnterSubRule(19);
			while (true)
			{
				int alt19=2;
				try { DebugEnterDecision(19, false);
				int LA19_1 = input.LA(1);

				if ((LA19_1==DOT))
				{
					alt19 = 1;
				}


				} finally { DebugExitDecision(19); }
				switch ( alt19 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\Alexandr\\Sources\\Repos\\Expressions\\Expressions\\Flee\\Flee.g:135:41: DOT e= IDENTIFIER
					{
					DebugLocation(135, 41);
					DOT32=(CommonToken)Match(input,DOT,Follow._DOT_in_type_identifier783); 
					DOT32_tree = (CommonTree)adaptor.Create(DOT32);
					adaptor.AddChild(root_0, DOT32_tree);
					DebugLocation(135, 46);
					e=(CommonToken)Match(input,IDENTIFIER,Follow._IDENTIFIER_in_type_identifier787); 
					e_tree = (CommonTree)adaptor.Create(e);
					adaptor.AddChild(root_0, e_tree);
					DebugLocation(135, 58);
					 retval.value = retval.value + "." + (e!=null?e.Text:null); 

					}
					break;

				default:
					goto loop19;
				}
			}

			loop19:
				;

			} finally { DebugExitSubRule(19); }


			}

			retval.Stop = (CommonToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}

		    catch (RecognitionException) 
		    {
		        throw;
		    }

		finally
		{
			TraceOut("type_identifier", 15);
			LeaveRule("type_identifier", 15);
			LeaveRule_type_identifier();
		}
		DebugLocation(136, 1);
		} finally { DebugExitRule(GrammarFileName, "type_identifier"); }
		return retval;

	}
	// $ANTLR end "type_identifier"

	private sealed partial class if_expression_return : AstParserRuleReturnScope<CommonTree, CommonToken>
	{
		public IAstNode value;
		public if_expression_return(FleeParser grammar) {OnCreated(grammar);}
		partial void OnCreated(FleeParser grammar);
	}

	partial void EnterRule_if_expression();
	partial void LeaveRule_if_expression();
	// $ANTLR start "if_expression"
	// C:\\Users\\Alexandr\\Sources\\Repos\\Expressions\\Expressions\\Flee\\Flee.g:138:1: if_expression returns [IAstNode value] : ( IF '(' e= expression ',' t= expression ',' l= expression ')' |u= unary_expression );
	[GrammarRule("if_expression")]
	private FleeParser.if_expression_return if_expression()
	{
		EnterRule_if_expression();
		EnterRule("if_expression", 16);
		TraceIn("if_expression", 16);
		FleeParser.if_expression_return retval = new FleeParser.if_expression_return(this);
		retval.Start = (CommonToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		CommonToken IF33 = default(CommonToken);
		CommonToken char_literal34 = default(CommonToken);
		CommonToken char_literal35 = default(CommonToken);
		CommonToken char_literal36 = default(CommonToken);
		CommonToken char_literal37 = default(CommonToken);
		FleeParser.expression_return e = default(FleeParser.expression_return);
		FleeParser.expression_return t = default(FleeParser.expression_return);
		FleeParser.expression_return l = default(FleeParser.expression_return);
		FleeParser.unary_expression_return u = default(FleeParser.unary_expression_return);

		CommonTree IF33_tree = default(CommonTree);
		CommonTree char_literal34_tree = default(CommonTree);
		CommonTree char_literal35_tree = default(CommonTree);
		CommonTree char_literal36_tree = default(CommonTree);
		CommonTree char_literal37_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "if_expression");
		DebugLocation(138, 1);
		try
		{
			// C:\\Users\\Alexandr\\Sources\\Repos\\Expressions\\Expressions\\Flee\\Flee.g:139:2: ( IF '(' e= expression ',' t= expression ',' l= expression ')' |u= unary_expression )
			int alt20=2;
			try { DebugEnterDecision(20, false);
			int LA20_1 = input.LA(1);

			if ((LA20_1==IF))
			{
				alt20 = 1;
			}
			else if (((LA20_1>=CHARACTER_LITERAL && LA20_1<=DECIMAL_LITERAL)||(LA20_1>=FALSE && LA20_1<=FLOATING_POINT_LITERAL)||LA20_1==HEX_LITERAL||LA20_1==IDENTIFIER||LA20_1==NULL||(LA20_1>=STRING_LITERAL && LA20_1<=TRUE)||LA20_1==33||LA20_1==36||LA20_1==38))
			{
				alt20 = 2;
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 20, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(20); }
			switch (alt20)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\Alexandr\\Sources\\Repos\\Expressions\\Expressions\\Flee\\Flee.g:139:4: IF '(' e= expression ',' t= expression ',' l= expression ')'
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(139, 4);
				IF33=(CommonToken)Match(input,IF,Follow._IF_in_if_expression807); 
				IF33_tree = (CommonTree)adaptor.Create(IF33);
				adaptor.AddChild(root_0, IF33_tree);
				DebugLocation(139, 7);
				char_literal34=(CommonToken)Match(input,33,Follow._33_in_if_expression809); 
				char_literal34_tree = (CommonTree)adaptor.Create(char_literal34);
				adaptor.AddChild(root_0, char_literal34_tree);
				DebugLocation(139, 12);
				PushFollow(Follow._expression_in_if_expression813);
				e=expression();
				PopFollow();

				adaptor.AddChild(root_0, e.Tree);
				DebugLocation(139, 24);
				char_literal35=(CommonToken)Match(input,37,Follow._37_in_if_expression815); 
				char_literal35_tree = (CommonTree)adaptor.Create(char_literal35);
				adaptor.AddChild(root_0, char_literal35_tree);
				DebugLocation(139, 29);
				PushFollow(Follow._expression_in_if_expression819);
				t=expression();
				PopFollow();

				adaptor.AddChild(root_0, t.Tree);
				DebugLocation(139, 41);
				char_literal36=(CommonToken)Match(input,37,Follow._37_in_if_expression821); 
				char_literal36_tree = (CommonTree)adaptor.Create(char_literal36);
				adaptor.AddChild(root_0, char_literal36_tree);
				DebugLocation(139, 46);
				PushFollow(Follow._expression_in_if_expression825);
				l=expression();
				PopFollow();

				adaptor.AddChild(root_0, l.Tree);
				DebugLocation(139, 58);
				char_literal37=(CommonToken)Match(input,34,Follow._34_in_if_expression827); 
				char_literal37_tree = (CommonTree)adaptor.Create(char_literal37);
				adaptor.AddChild(root_0, char_literal37_tree);
				DebugLocation(139, 62);
				 retval.value = new Conditional((e!=null?e.value:default(IAstNode)), (t!=null?t.value:default(IAstNode)), (l!=null?l.value:default(IAstNode))); 

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\Users\\Alexandr\\Sources\\Repos\\Expressions\\Expressions\\Flee\\Flee.g:140:4: u= unary_expression
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(140, 5);
				PushFollow(Follow._unary_expression_in_if_expression836);
				u=unary_expression();
				PopFollow();

				adaptor.AddChild(root_0, u.Tree);
				DebugLocation(140, 23);
				 retval.value = (u!=null?u.value:default(IAstNode)); 

				}
				break;

			}
			retval.Stop = (CommonToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}

		    catch (RecognitionException) 
		    {
		        throw;
		    }

		finally
		{
			TraceOut("if_expression", 16);
			LeaveRule("if_expression", 16);
			LeaveRule_if_expression();
		}
		DebugLocation(141, 1);
		} finally { DebugExitRule(GrammarFileName, "if_expression"); }
		return retval;

	}
	// $ANTLR end "if_expression"

	private sealed partial class unary_expression_return : AstParserRuleReturnScope<CommonTree, CommonToken>
	{
		public IAstNode value;
		public unary_expression_return(FleeParser grammar) {OnCreated(grammar);}
		partial void OnCreated(FleeParser grammar);
	}

	partial void EnterRule_unary_expression();
	partial void LeaveRule_unary_expression();
	// $ANTLR start "unary_expression"
	// C:\\Users\\Alexandr\\Sources\\Repos\\Expressions\\Expressions\\Flee\\Flee.g:143:1: unary_expression returns [IAstNode value] : (p= postfix_expression | ( '+' e= cast_expression | '-' e= cast_expression ) );
	[GrammarRule("unary_expression")]
	private FleeParser.unary_expression_return unary_expression()
	{
		EnterRule_unary_expression();
		EnterRule("unary_expression", 17);
		TraceIn("unary_expression", 17);
		FleeParser.unary_expression_return retval = new FleeParser.unary_expression_return(this);
		retval.Start = (CommonToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		CommonToken char_literal38 = default(CommonToken);
		CommonToken char_literal39 = default(CommonToken);
		FleeParser.postfix_expression_return p = default(FleeParser.postfix_expression_return);
		FleeParser.cast_expression_return e = default(FleeParser.cast_expression_return);

		CommonTree char_literal38_tree = default(CommonTree);
		CommonTree char_literal39_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "unary_expression");
		DebugLocation(143, 1);
		try
		{
			// C:\\Users\\Alexandr\\Sources\\Repos\\Expressions\\Expressions\\Flee\\Flee.g:144:2: (p= postfix_expression | ( '+' e= cast_expression | '-' e= cast_expression ) )
			int alt22=2;
			try { DebugEnterDecision(22, false);
			int LA22_1 = input.LA(1);

			if (((LA22_1>=CHARACTER_LITERAL && LA22_1<=DECIMAL_LITERAL)||(LA22_1>=FALSE && LA22_1<=FLOATING_POINT_LITERAL)||LA22_1==HEX_LITERAL||LA22_1==IDENTIFIER||LA22_1==NULL||(LA22_1>=STRING_LITERAL && LA22_1<=TRUE)||LA22_1==33))
			{
				alt22 = 1;
			}
			else if ((LA22_1==36||LA22_1==38))
			{
				alt22 = 2;
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 22, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(22); }
			switch (alt22)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\Alexandr\\Sources\\Repos\\Expressions\\Expressions\\Flee\\Flee.g:144:4: p= postfix_expression
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(144, 5);
				PushFollow(Follow._postfix_expression_in_unary_expression855);
				p=postfix_expression();
				PopFollow();

				adaptor.AddChild(root_0, p.Tree);
				DebugLocation(144, 25);
				 retval.value = (p!=null?p.value:default(IAstNode)); 

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\Users\\Alexandr\\Sources\\Repos\\Expressions\\Expressions\\Flee\\Flee.g:146:3: ( '+' e= cast_expression | '-' e= cast_expression )
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(146, 3);
				// C:\\Users\\Alexandr\\Sources\\Repos\\Expressions\\Expressions\\Flee\\Flee.g:146:3: ( '+' e= cast_expression | '-' e= cast_expression )
				int alt21=2;
				try { DebugEnterSubRule(21);
				try { DebugEnterDecision(21, false);
				int LA21_1 = input.LA(1);

				if ((LA21_1==36))
				{
					alt21 = 1;
				}
				else if ((LA21_1==38))
				{
					alt21 = 2;
				}
				else
				{
					NoViableAltException nvae = new NoViableAltException("", 21, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				} finally { DebugExitDecision(21); }
				switch (alt21)
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\Alexandr\\Sources\\Repos\\Expressions\\Expressions\\Flee\\Flee.g:146:5: '+' e= cast_expression
					{
					DebugLocation(146, 5);
					char_literal38=(CommonToken)Match(input,36,Follow._36_in_unary_expression866); 
					char_literal38_tree = (CommonTree)adaptor.Create(char_literal38);
					adaptor.AddChild(root_0, char_literal38_tree);
					DebugLocation(146, 10);
					PushFollow(Follow._cast_expression_in_unary_expression870);
					e=cast_expression();
					PopFollow();

					adaptor.AddChild(root_0, e.Tree);
					DebugLocation(146, 27);
					 retval.value = new UnaryExpression((e!=null?e.value:default(IAstNode)), ExpressionType.Plus); 

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// C:\\Users\\Alexandr\\Sources\\Repos\\Expressions\\Expressions\\Flee\\Flee.g:147:5: '-' e= cast_expression
					{
					DebugLocation(147, 5);
					char_literal39=(CommonToken)Match(input,38,Follow._38_in_unary_expression878); 
					char_literal39_tree = (CommonTree)adaptor.Create(char_literal39);
					adaptor.AddChild(root_0, char_literal39_tree);
					DebugLocation(147, 10);
					PushFollow(Follow._cast_expression_in_unary_expression882);
					e=cast_expression();
					PopFollow();

					adaptor.AddChild(root_0, e.Tree);
					DebugLocation(147, 27);
					 retval.value = new UnaryExpression((e!=null?e.value:default(IAstNode)), ExpressionType.Minus); 

					}
					break;

				}
				} finally { DebugExitSubRule(21); }


				}
				break;

			}
			retval.Stop = (CommonToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}

		    catch (RecognitionException) 
		    {
		        throw;
		    }

		finally
		{
			TraceOut("unary_expression", 17);
			LeaveRule("unary_expression", 17);
			LeaveRule_unary_expression();
		}
		DebugLocation(149, 1);
		} finally { DebugExitRule(GrammarFileName, "unary_expression"); }
		return retval;

	}
	// $ANTLR end "unary_expression"

	private sealed partial class argument_expression_list_return : AstParserRuleReturnScope<CommonTree, CommonToken>
	{
		public AstNodeCollection value;
		public argument_expression_list_return(FleeParser grammar) {OnCreated(grammar);}
		partial void OnCreated(FleeParser grammar);
	}

	partial void EnterRule_argument_expression_list();
	partial void LeaveRule_argument_expression_list();
	// $ANTLR start "argument_expression_list"
	// C:\\Users\\Alexandr\\Sources\\Repos\\Expressions\\Expressions\\Flee\\Flee.g:151:1: argument_expression_list returns [AstNodeCollection value] : e= expression ( ',' e= expression )* ;
	[GrammarRule("argument_expression_list")]
	private FleeParser.argument_expression_list_return argument_expression_list()
	{
		EnterRule_argument_expression_list();
		EnterRule("argument_expression_list", 18);
		TraceIn("argument_expression_list", 18);
		FleeParser.argument_expression_list_return retval = new FleeParser.argument_expression_list_return(this);
		retval.Start = (CommonToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		CommonToken char_literal40 = default(CommonToken);
		FleeParser.expression_return e = default(FleeParser.expression_return);

		CommonTree char_literal40_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "argument_expression_list");
		DebugLocation(151, 1);
		try
		{
			// C:\\Users\\Alexandr\\Sources\\Repos\\Expressions\\Expressions\\Flee\\Flee.g:152:2: (e= expression ( ',' e= expression )* )
			DebugEnterAlt(1);
			// C:\\Users\\Alexandr\\Sources\\Repos\\Expressions\\Expressions\\Flee\\Flee.g:152:4: e= expression ( ',' e= expression )*
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(152, 5);
			PushFollow(Follow._expression_in_argument_expression_list905);
			e=expression();
			PopFollow();

			adaptor.AddChild(root_0, e.Tree);
			DebugLocation(152, 17);
			 retval.value = new AstNodeCollection((e!=null?e.value:default(IAstNode))); 
			DebugLocation(153, 3);
			// C:\\Users\\Alexandr\\Sources\\Repos\\Expressions\\Expressions\\Flee\\Flee.g:153:3: ( ',' e= expression )*
			try { DebugEnterSubRule(23);
			while (true)
			{
				int alt23=2;
				try { DebugEnterDecision(23, false);
				int LA23_1 = input.LA(1);

				if ((LA23_1==37))
				{
					alt23 = 1;
				}


				} finally { DebugExitDecision(23); }
				switch ( alt23 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\Alexandr\\Sources\\Repos\\Expressions\\Expressions\\Flee\\Flee.g:153:5: ',' e= expression
					{
					DebugLocation(153, 5);
					char_literal40=(CommonToken)Match(input,37,Follow._37_in_argument_expression_list913); 
					char_literal40_tree = (CommonTree)adaptor.Create(char_literal40);
					adaptor.AddChild(root_0, char_literal40_tree);
					DebugLocation(153, 10);
					PushFollow(Follow._expression_in_argument_expression_list917);
					e=expression();
					PopFollow();

					adaptor.AddChild(root_0, e.Tree);
					DebugLocation(153, 22);
					 retval.value = new AstNodeCollection(retval.value, (e!=null?e.value:default(IAstNode))); 

					}
					break;

				default:
					goto loop23;
				}
			}

			loop23:
				;

			} finally { DebugExitSubRule(23); }


			}

			retval.Stop = (CommonToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}

		    catch (RecognitionException) 
		    {
		        throw;
		    }

		finally
		{
			TraceOut("argument_expression_list", 18);
			LeaveRule("argument_expression_list", 18);
			LeaveRule_argument_expression_list();
		}
		DebugLocation(155, 1);
		} finally { DebugExitRule(GrammarFileName, "argument_expression_list"); }
		return retval;

	}
	// $ANTLR end "argument_expression_list"

	private sealed partial class postfix_expression_return : AstParserRuleReturnScope<CommonTree, CommonToken>
	{
		public IAstNode value;
		public postfix_expression_return(FleeParser grammar) {OnCreated(grammar);}
		partial void OnCreated(FleeParser grammar);
	}

	partial void EnterRule_postfix_expression();
	partial void LeaveRule_postfix_expression();
	// $ANTLR start "postfix_expression"
	// C:\\Users\\Alexandr\\Sources\\Repos\\Expressions\\Expressions\\Flee\\Flee.g:157:1: postfix_expression returns [IAstNode value] : p= primary_expression ( '[' e= argument_expression_list ']' | '(' ')' | '(' e= argument_expression_list ')' | DOT IDENTIFIER )* ;
	[GrammarRule("postfix_expression")]
	private FleeParser.postfix_expression_return postfix_expression()
	{
		EnterRule_postfix_expression();
		EnterRule("postfix_expression", 19);
		TraceIn("postfix_expression", 19);
		FleeParser.postfix_expression_return retval = new FleeParser.postfix_expression_return(this);
		retval.Start = (CommonToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		CommonToken char_literal41 = default(CommonToken);
		CommonToken char_literal42 = default(CommonToken);
		CommonToken char_literal43 = default(CommonToken);
		CommonToken char_literal44 = default(CommonToken);
		CommonToken char_literal45 = default(CommonToken);
		CommonToken char_literal46 = default(CommonToken);
		CommonToken DOT47 = default(CommonToken);
		CommonToken IDENTIFIER48 = default(CommonToken);
		FleeParser.primary_expression_return p = default(FleeParser.primary_expression_return);
		FleeParser.argument_expression_list_return e = default(FleeParser.argument_expression_list_return);

		CommonTree char_literal41_tree = default(CommonTree);
		CommonTree char_literal42_tree = default(CommonTree);
		CommonTree char_literal43_tree = default(CommonTree);
		CommonTree char_literal44_tree = default(CommonTree);
		CommonTree char_literal45_tree = default(CommonTree);
		CommonTree char_literal46_tree = default(CommonTree);
		CommonTree DOT47_tree = default(CommonTree);
		CommonTree IDENTIFIER48_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "postfix_expression");
		DebugLocation(157, 1);
		try
		{
			// C:\\Users\\Alexandr\\Sources\\Repos\\Expressions\\Expressions\\Flee\\Flee.g:158:2: (p= primary_expression ( '[' e= argument_expression_list ']' | '(' ')' | '(' e= argument_expression_list ')' | DOT IDENTIFIER )* )
			DebugEnterAlt(1);
			// C:\\Users\\Alexandr\\Sources\\Repos\\Expressions\\Expressions\\Flee\\Flee.g:158:4: p= primary_expression ( '[' e= argument_expression_list ']' | '(' ')' | '(' e= argument_expression_list ')' | DOT IDENTIFIER )*
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(158, 5);
			PushFollow(Follow._primary_expression_in_postfix_expression941);
			p=primary_expression();
			PopFollow();

			adaptor.AddChild(root_0, p.Tree);
			DebugLocation(158, 25);
			 retval.value = (p!=null?p.value:default(IAstNode)); 
			DebugLocation(159, 3);
			// C:\\Users\\Alexandr\\Sources\\Repos\\Expressions\\Expressions\\Flee\\Flee.g:159:3: ( '[' e= argument_expression_list ']' | '(' ')' | '(' e= argument_expression_list ')' | DOT IDENTIFIER )*
			try { DebugEnterSubRule(24);
			while (true)
			{
				int alt24=5;
				try { DebugEnterDecision(24, false);
				switch (input.LA(1))
				{
				case 48:
					{
					alt24 = 1;
					}
					break;
				case 33:
					{
					int LA24_2 = input.LA(2);

					if ((LA24_2==34))
					{
						alt24 = 2;
					}
					else if (((LA24_2>=CAST && LA24_2<=DECIMAL_LITERAL)||(LA24_2>=FALSE && LA24_2<=FLOATING_POINT_LITERAL)||LA24_2==HEX_LITERAL||(LA24_2>=IDENTIFIER && LA24_2<=IF)||(LA24_2>=NOT && LA24_2<=NULL)||(LA24_2>=STRING_LITERAL && LA24_2<=TRUE)||LA24_2==33||LA24_2==36||LA24_2==38))
					{
						alt24 = 3;
					}


					}
					break;
				case DOT:
					{
					alt24 = 4;
					}
					break;
				}

				} finally { DebugExitDecision(24); }
				switch ( alt24 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\Alexandr\\Sources\\Repos\\Expressions\\Expressions\\Flee\\Flee.g:159:5: '[' e= argument_expression_list ']'
					{
					DebugLocation(159, 5);
					char_literal41=(CommonToken)Match(input,48,Follow._48_in_postfix_expression949); 
					char_literal41_tree = (CommonTree)adaptor.Create(char_literal41);
					adaptor.AddChild(root_0, char_literal41_tree);
					DebugLocation(159, 10);
					PushFollow(Follow._argument_expression_list_in_postfix_expression953);
					e=argument_expression_list();
					PopFollow();

					adaptor.AddChild(root_0, e.Tree);
					DebugLocation(159, 36);
					char_literal42=(CommonToken)Match(input,49,Follow._49_in_postfix_expression955); 
					char_literal42_tree = (CommonTree)adaptor.Create(char_literal42);
					adaptor.AddChild(root_0, char_literal42_tree);
					DebugLocation(159, 40);
					 retval.value = new Index(retval.value, (e!=null?e.value:default(AstNodeCollection))); 

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// C:\\Users\\Alexandr\\Sources\\Repos\\Expressions\\Expressions\\Flee\\Flee.g:160:5: '(' ')'
					{
					DebugLocation(160, 5);
					char_literal43=(CommonToken)Match(input,33,Follow._33_in_postfix_expression963); 
					char_literal43_tree = (CommonTree)adaptor.Create(char_literal43);
					adaptor.AddChild(root_0, char_literal43_tree);
					DebugLocation(160, 9);
					char_literal44=(CommonToken)Match(input,34,Follow._34_in_postfix_expression965); 
					char_literal44_tree = (CommonTree)adaptor.Create(char_literal44);
					adaptor.AddChild(root_0, char_literal44_tree);
					DebugLocation(160, 13);
					 retval.value = new MethodCall(retval.value); 

					}
					break;
				case 3:
					DebugEnterAlt(3);
					// C:\\Users\\Alexandr\\Sources\\Repos\\Expressions\\Expressions\\Flee\\Flee.g:161:5: '(' e= argument_expression_list ')'
					{
					DebugLocation(161, 5);
					char_literal45=(CommonToken)Match(input,33,Follow._33_in_postfix_expression973); 
					char_literal45_tree = (CommonTree)adaptor.Create(char_literal45);
					adaptor.AddChild(root_0, char_literal45_tree);
					DebugLocation(161, 10);
					PushFollow(Follow._argument_expression_list_in_postfix_expression977);
					e=argument_expression_list();
					PopFollow();

					adaptor.AddChild(root_0, e.Tree);
					DebugLocation(161, 36);
					char_literal46=(CommonToken)Match(input,34,Follow._34_in_postfix_expression979); 
					char_literal46_tree = (CommonTree)adaptor.Create(char_literal46);
					adaptor.AddChild(root_0, char_literal46_tree);
					DebugLocation(161, 40);
					 retval.value = new MethodCall(retval.value, (e!=null?e.value:default(AstNodeCollection))); 

					}
					break;
				case 4:
					DebugEnterAlt(4);
					// C:\\Users\\Alexandr\\Sources\\Repos\\Expressions\\Expressions\\Flee\\Flee.g:162:5: DOT IDENTIFIER
					{
					DebugLocation(162, 5);
					DOT47=(CommonToken)Match(input,DOT,Follow._DOT_in_postfix_expression987); 
					DOT47_tree = (CommonTree)adaptor.Create(DOT47);
					adaptor.AddChild(root_0, DOT47_tree);
					DebugLocation(162, 9);
					IDENTIFIER48=(CommonToken)Match(input,IDENTIFIER,Follow._IDENTIFIER_in_postfix_expression989); 
					IDENTIFIER48_tree = (CommonTree)adaptor.Create(IDENTIFIER48);
					adaptor.AddChild(root_0, IDENTIFIER48_tree);
					DebugLocation(162, 20);
					 retval.value = new MemberAccess(retval.value, (IDENTIFIER48!=null?IDENTIFIER48.Text:null)); 

					}
					break;

				default:
					goto loop24;
				}
			}

			loop24:
				;

			} finally { DebugExitSubRule(24); }


			}

			retval.Stop = (CommonToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}

		    catch (RecognitionException) 
		    {
		        throw;
		    }

		finally
		{
			TraceOut("postfix_expression", 19);
			LeaveRule("postfix_expression", 19);
			LeaveRule_postfix_expression();
		}
		DebugLocation(164, 1);
		} finally { DebugExitRule(GrammarFileName, "postfix_expression"); }
		return retval;

	}
	// $ANTLR end "postfix_expression"

	private sealed partial class primary_expression_return : AstParserRuleReturnScope<CommonTree, CommonToken>
	{
		public IAstNode value;
		public primary_expression_return(FleeParser grammar) {OnCreated(grammar);}
		partial void OnCreated(FleeParser grammar);
	}

	partial void EnterRule_primary_expression();
	partial void LeaveRule_primary_expression();
	// $ANTLR start "primary_expression"
	// C:\\Users\\Alexandr\\Sources\\Repos\\Expressions\\Expressions\\Flee\\Flee.g:166:1: primary_expression returns [IAstNode value] : ( IDENTIFIER | constant | '(' expression ')' );
	[GrammarRule("primary_expression")]
	private FleeParser.primary_expression_return primary_expression()
	{
		EnterRule_primary_expression();
		EnterRule("primary_expression", 20);
		TraceIn("primary_expression", 20);
		FleeParser.primary_expression_return retval = new FleeParser.primary_expression_return(this);
		retval.Start = (CommonToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		CommonToken IDENTIFIER49 = default(CommonToken);
		CommonToken char_literal51 = default(CommonToken);
		CommonToken char_literal53 = default(CommonToken);
		FleeParser.constant_return constant50 = default(FleeParser.constant_return);
		FleeParser.expression_return expression52 = default(FleeParser.expression_return);

		CommonTree IDENTIFIER49_tree = default(CommonTree);
		CommonTree char_literal51_tree = default(CommonTree);
		CommonTree char_literal53_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "primary_expression");
		DebugLocation(166, 1);
		try
		{
			// C:\\Users\\Alexandr\\Sources\\Repos\\Expressions\\Expressions\\Flee\\Flee.g:167:2: ( IDENTIFIER | constant | '(' expression ')' )
			int alt25=3;
			try { DebugEnterDecision(25, false);
			switch (input.LA(1))
			{
			case IDENTIFIER:
				{
				alt25 = 1;
				}
				break;
			case CHARACTER_LITERAL:
			case DATETIME_LITERAL:
			case DECIMAL_LITERAL:
			case FALSE:
			case FLOATING_POINT_LITERAL:
			case HEX_LITERAL:
			case NULL:
			case STRING_LITERAL:
			case TIMESPAN_LITERAL:
			case TRUE:
				{
				alt25 = 2;
				}
				break;
			case 33:
				{
				alt25 = 3;
				}
				break;
			default:
				{
					NoViableAltException nvae = new NoViableAltException("", 25, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(25); }
			switch (alt25)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\Alexandr\\Sources\\Repos\\Expressions\\Expressions\\Flee\\Flee.g:167:4: IDENTIFIER
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(167, 4);
				IDENTIFIER49=(CommonToken)Match(input,IDENTIFIER,Follow._IDENTIFIER_in_primary_expression1011); 
				IDENTIFIER49_tree = (CommonTree)adaptor.Create(IDENTIFIER49);
				adaptor.AddChild(root_0, IDENTIFIER49_tree);
				DebugLocation(167, 15);
				 retval.value = CreateIdentifier((IDENTIFIER49!=null?IDENTIFIER49.Text:null)); 

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\Users\\Alexandr\\Sources\\Repos\\Expressions\\Expressions\\Flee\\Flee.g:168:4: constant
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(168, 4);
				PushFollow(Follow._constant_in_primary_expression1018);
				constant50=constant();
				PopFollow();

				adaptor.AddChild(root_0, constant50.Tree);
				DebugLocation(168, 13);
				 retval.value = (constant50!=null?constant50.value:default(Constant)); 

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// C:\\Users\\Alexandr\\Sources\\Repos\\Expressions\\Expressions\\Flee\\Flee.g:169:4: '(' expression ')'
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(169, 4);
				char_literal51=(CommonToken)Match(input,33,Follow._33_in_primary_expression1025); 
				char_literal51_tree = (CommonTree)adaptor.Create(char_literal51);
				adaptor.AddChild(root_0, char_literal51_tree);
				DebugLocation(169, 8);
				PushFollow(Follow._expression_in_primary_expression1027);
				expression52=expression();
				PopFollow();

				adaptor.AddChild(root_0, expression52.Tree);
				DebugLocation(169, 19);
				char_literal53=(CommonToken)Match(input,34,Follow._34_in_primary_expression1029); 
				char_literal53_tree = (CommonTree)adaptor.Create(char_literal53);
				adaptor.AddChild(root_0, char_literal53_tree);
				DebugLocation(169, 23);
				 retval.value = new UnaryExpression((expression52!=null?expression52.value:default(IAstNode)), ExpressionType.Group); 

				}
				break;

			}
			retval.Stop = (CommonToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}

		    catch (RecognitionException) 
		    {
		        throw;
		    }

		finally
		{
			TraceOut("primary_expression", 20);
			LeaveRule("primary_expression", 20);
			LeaveRule_primary_expression();
		}
		DebugLocation(170, 1);
		} finally { DebugExitRule(GrammarFileName, "primary_expression"); }
		return retval;

	}
	// $ANTLR end "primary_expression"

	private sealed partial class constant_return : AstParserRuleReturnScope<CommonTree, CommonToken>
	{
		public Constant value;
		public constant_return(FleeParser grammar) {OnCreated(grammar);}
		partial void OnCreated(FleeParser grammar);
	}

	partial void EnterRule_constant();
	partial void LeaveRule_constant();
	// $ANTLR start "constant"
	// C:\\Users\\Alexandr\\Sources\\Repos\\Expressions\\Expressions\\Flee\\Flee.g:172:1: constant returns [Constant value] : ( TRUE | FALSE | NULL | DATETIME_LITERAL | TIMESPAN_LITERAL | HEX_LITERAL | DECIMAL_LITERAL | CHARACTER_LITERAL | STRING_LITERAL | FLOATING_POINT_LITERAL );
	[GrammarRule("constant")]
	private FleeParser.constant_return constant()
	{
		EnterRule_constant();
		EnterRule("constant", 21);
		TraceIn("constant", 21);
		FleeParser.constant_return retval = new FleeParser.constant_return(this);
		retval.Start = (CommonToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		CommonToken TRUE54 = default(CommonToken);
		CommonToken FALSE55 = default(CommonToken);
		CommonToken NULL56 = default(CommonToken);
		CommonToken DATETIME_LITERAL57 = default(CommonToken);
		CommonToken TIMESPAN_LITERAL58 = default(CommonToken);
		CommonToken HEX_LITERAL59 = default(CommonToken);
		CommonToken DECIMAL_LITERAL60 = default(CommonToken);
		CommonToken CHARACTER_LITERAL61 = default(CommonToken);
		CommonToken STRING_LITERAL62 = default(CommonToken);
		CommonToken FLOATING_POINT_LITERAL63 = default(CommonToken);

		CommonTree TRUE54_tree = default(CommonTree);
		CommonTree FALSE55_tree = default(CommonTree);
		CommonTree NULL56_tree = default(CommonTree);
		CommonTree DATETIME_LITERAL57_tree = default(CommonTree);
		CommonTree TIMESPAN_LITERAL58_tree = default(CommonTree);
		CommonTree HEX_LITERAL59_tree = default(CommonTree);
		CommonTree DECIMAL_LITERAL60_tree = default(CommonTree);
		CommonTree CHARACTER_LITERAL61_tree = default(CommonTree);
		CommonTree STRING_LITERAL62_tree = default(CommonTree);
		CommonTree FLOATING_POINT_LITERAL63_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "constant");
		DebugLocation(172, 1);
		try
		{
			// C:\\Users\\Alexandr\\Sources\\Repos\\Expressions\\Expressions\\Flee\\Flee.g:173:2: ( TRUE | FALSE | NULL | DATETIME_LITERAL | TIMESPAN_LITERAL | HEX_LITERAL | DECIMAL_LITERAL | CHARACTER_LITERAL | STRING_LITERAL | FLOATING_POINT_LITERAL )
			int alt26=10;
			try { DebugEnterDecision(26, false);
			switch (input.LA(1))
			{
			case TRUE:
				{
				alt26 = 1;
				}
				break;
			case FALSE:
				{
				alt26 = 2;
				}
				break;
			case NULL:
				{
				alt26 = 3;
				}
				break;
			case DATETIME_LITERAL:
				{
				alt26 = 4;
				}
				break;
			case TIMESPAN_LITERAL:
				{
				alt26 = 5;
				}
				break;
			case HEX_LITERAL:
				{
				alt26 = 6;
				}
				break;
			case DECIMAL_LITERAL:
				{
				alt26 = 7;
				}
				break;
			case CHARACTER_LITERAL:
				{
				alt26 = 8;
				}
				break;
			case STRING_LITERAL:
				{
				alt26 = 9;
				}
				break;
			case FLOATING_POINT_LITERAL:
				{
				alt26 = 10;
				}
				break;
			default:
				{
					NoViableAltException nvae = new NoViableAltException("", 26, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(26); }
			switch (alt26)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\Alexandr\\Sources\\Repos\\Expressions\\Expressions\\Flee\\Flee.g:173:4: TRUE
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(173, 4);
				TRUE54=(CommonToken)Match(input,TRUE,Follow._TRUE_in_constant1046); 
				TRUE54_tree = (CommonTree)adaptor.Create(TRUE54);
				adaptor.AddChild(root_0, TRUE54_tree);
				DebugLocation(173, 9);
				 retval.value = Constant.True; 

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\Users\\Alexandr\\Sources\\Repos\\Expressions\\Expressions\\Flee\\Flee.g:174:4: FALSE
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(174, 4);
				FALSE55=(CommonToken)Match(input,FALSE,Follow._FALSE_in_constant1053); 
				FALSE55_tree = (CommonTree)adaptor.Create(FALSE55);
				adaptor.AddChild(root_0, FALSE55_tree);
				DebugLocation(174, 10);
				 retval.value = Constant.False; 

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// C:\\Users\\Alexandr\\Sources\\Repos\\Expressions\\Expressions\\Flee\\Flee.g:175:4: NULL
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(175, 4);
				NULL56=(CommonToken)Match(input,NULL,Follow._NULL_in_constant1060); 
				NULL56_tree = (CommonTree)adaptor.Create(NULL56);
				adaptor.AddChild(root_0, NULL56_tree);
				DebugLocation(175, 9);
				 retval.value = Constant.Null; 

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// C:\\Users\\Alexandr\\Sources\\Repos\\Expressions\\Expressions\\Flee\\Flee.g:176:4: DATETIME_LITERAL
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(176, 4);
				DATETIME_LITERAL57=(CommonToken)Match(input,DATETIME_LITERAL,Follow._DATETIME_LITERAL_in_constant1067); 
				DATETIME_LITERAL57_tree = (CommonTree)adaptor.Create(DATETIME_LITERAL57);
				adaptor.AddChild(root_0, DATETIME_LITERAL57_tree);
				DebugLocation(176, 21);
				 retval.value = ParseDateTime((DATETIME_LITERAL57!=null?DATETIME_LITERAL57.Text:null)); 

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// C:\\Users\\Alexandr\\Sources\\Repos\\Expressions\\Expressions\\Flee\\Flee.g:177:4: TIMESPAN_LITERAL
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(177, 4);
				TIMESPAN_LITERAL58=(CommonToken)Match(input,TIMESPAN_LITERAL,Follow._TIMESPAN_LITERAL_in_constant1074); 
				TIMESPAN_LITERAL58_tree = (CommonTree)adaptor.Create(TIMESPAN_LITERAL58);
				adaptor.AddChild(root_0, TIMESPAN_LITERAL58_tree);
				DebugLocation(177, 21);
				 retval.value = ParseTimeSpan((TIMESPAN_LITERAL58!=null?TIMESPAN_LITERAL58.Text:null)); 

				}
				break;
			case 6:
				DebugEnterAlt(6);
				// C:\\Users\\Alexandr\\Sources\\Repos\\Expressions\\Expressions\\Flee\\Flee.g:178:4: HEX_LITERAL
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(178, 4);
				HEX_LITERAL59=(CommonToken)Match(input,HEX_LITERAL,Follow._HEX_LITERAL_in_constant1081); 
				HEX_LITERAL59_tree = (CommonTree)adaptor.Create(HEX_LITERAL59);
				adaptor.AddChild(root_0, HEX_LITERAL59_tree);
				DebugLocation(178, 16);
				 retval.value = ParseHex((HEX_LITERAL59!=null?HEX_LITERAL59.Text:null)); 

				}
				break;
			case 7:
				DebugEnterAlt(7);
				// C:\\Users\\Alexandr\\Sources\\Repos\\Expressions\\Expressions\\Flee\\Flee.g:179:4: DECIMAL_LITERAL
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(179, 4);
				DECIMAL_LITERAL60=(CommonToken)Match(input,DECIMAL_LITERAL,Follow._DECIMAL_LITERAL_in_constant1088); 
				DECIMAL_LITERAL60_tree = (CommonTree)adaptor.Create(DECIMAL_LITERAL60);
				adaptor.AddChild(root_0, DECIMAL_LITERAL60_tree);
				DebugLocation(179, 20);
				 retval.value = ParseDecimal((DECIMAL_LITERAL60!=null?DECIMAL_LITERAL60.Text:null)); 

				}
				break;
			case 8:
				DebugEnterAlt(8);
				// C:\\Users\\Alexandr\\Sources\\Repos\\Expressions\\Expressions\\Flee\\Flee.g:180:4: CHARACTER_LITERAL
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(180, 4);
				CHARACTER_LITERAL61=(CommonToken)Match(input,CHARACTER_LITERAL,Follow._CHARACTER_LITERAL_in_constant1095); 
				CHARACTER_LITERAL61_tree = (CommonTree)adaptor.Create(CHARACTER_LITERAL61);
				adaptor.AddChild(root_0, CHARACTER_LITERAL61_tree);
				DebugLocation(180, 22);
				 retval.value = ParseCharacter((CHARACTER_LITERAL61!=null?CHARACTER_LITERAL61.Text:null)); 

				}
				break;
			case 9:
				DebugEnterAlt(9);
				// C:\\Users\\Alexandr\\Sources\\Repos\\Expressions\\Expressions\\Flee\\Flee.g:181:4: STRING_LITERAL
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(181, 4);
				STRING_LITERAL62=(CommonToken)Match(input,STRING_LITERAL,Follow._STRING_LITERAL_in_constant1102); 
				STRING_LITERAL62_tree = (CommonTree)adaptor.Create(STRING_LITERAL62);
				adaptor.AddChild(root_0, STRING_LITERAL62_tree);
				DebugLocation(181, 19);
				 retval.value = ParseString((STRING_LITERAL62!=null?STRING_LITERAL62.Text:null)); 

				}
				break;
			case 10:
				DebugEnterAlt(10);
				// C:\\Users\\Alexandr\\Sources\\Repos\\Expressions\\Expressions\\Flee\\Flee.g:182:4: FLOATING_POINT_LITERAL
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(182, 4);
				FLOATING_POINT_LITERAL63=(CommonToken)Match(input,FLOATING_POINT_LITERAL,Follow._FLOATING_POINT_LITERAL_in_constant1109); 
				FLOATING_POINT_LITERAL63_tree = (CommonTree)adaptor.Create(FLOATING_POINT_LITERAL63);
				adaptor.AddChild(root_0, FLOATING_POINT_LITERAL63_tree);
				DebugLocation(182, 27);
				 retval.value = ParseFloatingPoint((FLOATING_POINT_LITERAL63!=null?FLOATING_POINT_LITERAL63.Text:null)); 

				}
				break;

			}
			retval.Stop = (CommonToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}

		    catch (RecognitionException) 
		    {
		        throw;
		    }

		finally
		{
			TraceOut("constant", 21);
			LeaveRule("constant", 21);
			LeaveRule_constant();
		}
		DebugLocation(183, 1);
		} finally { DebugExitRule(GrammarFileName, "constant"); }
		return retval;

	}
	// $ANTLR end "constant"
	#endregion Rules


	#region Follow sets
	private static class Follow
	{
		public static readonly BitSet _expression_in_prog97 = new BitSet(new ulong[]{0x0UL});
		public static readonly BitSet _EOF_in_prog101 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _logical_xor_expression_in_expression118 = new BitSet(new ulong[]{0x2000002UL});
		public static readonly BitSet _OR_in_expression126 = new BitSet(new ulong[]{0x521CCD61E0UL});
		public static readonly BitSet _logical_xor_expression_in_expression130 = new BitSet(new ulong[]{0x2000002UL});
		public static readonly BitSet _logical_and_expression_in_logical_xor_expression158 = new BitSet(new ulong[]{0x80000002UL});
		public static readonly BitSet _XOR_in_logical_xor_expression166 = new BitSet(new ulong[]{0x521CCD61E0UL});
		public static readonly BitSet _logical_and_expression_in_logical_xor_expression170 = new BitSet(new ulong[]{0x80000002UL});
		public static readonly BitSet _unary_not_expression_in_logical_and_expression198 = new BitSet(new ulong[]{0x12UL});
		public static readonly BitSet _AND_in_logical_and_expression206 = new BitSet(new ulong[]{0x521CCD61E0UL});
		public static readonly BitSet _unary_not_expression_in_logical_and_expression210 = new BitSet(new ulong[]{0x12UL});
		public static readonly BitSet _equality_expression_in_unary_not_expression238 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _NOT_in_unary_not_expression245 = new BitSet(new ulong[]{0x521CCD61E0UL});
		public static readonly BitSet _unary_not_expression_in_unary_not_expression249 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _in_expression_in_equality_expression268 = new BitSet(new ulong[]{0x180000000002UL});
		public static readonly BitSet _44_in_equality_expression281 = new BitSet(new ulong[]{0x521C8D61E0UL});
		public static readonly BitSet _in_expression_in_equality_expression285 = new BitSet(new ulong[]{0x180000000002UL});
		public static readonly BitSet _43_in_equality_expression294 = new BitSet(new ulong[]{0x521C8D61E0UL});
		public static readonly BitSet _in_expression_in_equality_expression298 = new BitSet(new ulong[]{0x180000000002UL});
		public static readonly BitSet _relational_expression_in_in_expression327 = new BitSet(new ulong[]{0x100002UL});
		public static readonly BitSet _IN_in_in_expression338 = new BitSet(new ulong[]{0x200040000UL});
		public static readonly BitSet _IDENTIFIER_in_in_expression346 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _33_in_in_expression356 = new BitSet(new ulong[]{0x521CCD61E0UL});
		public static readonly BitSet _argument_expression_list_in_in_expression360 = new BitSet(new ulong[]{0x400000000UL});
		public static readonly BitSet _34_in_in_expression362 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _shift_expression_in_relational_expression392 = new BitSet(new ulong[]{0x650000000002UL});
		public static readonly BitSet _40_in_relational_expression405 = new BitSet(new ulong[]{0x521C8D61E0UL});
		public static readonly BitSet _shift_expression_in_relational_expression409 = new BitSet(new ulong[]{0x650000000002UL});
		public static readonly BitSet _45_in_relational_expression418 = new BitSet(new ulong[]{0x521C8D61E0UL});
		public static readonly BitSet _shift_expression_in_relational_expression422 = new BitSet(new ulong[]{0x650000000002UL});
		public static readonly BitSet _42_in_relational_expression431 = new BitSet(new ulong[]{0x521C8D61E0UL});
		public static readonly BitSet _shift_expression_in_relational_expression435 = new BitSet(new ulong[]{0x650000000002UL});
		public static readonly BitSet _46_in_relational_expression444 = new BitSet(new ulong[]{0x521C8D61E0UL});
		public static readonly BitSet _shift_expression_in_relational_expression448 = new BitSet(new ulong[]{0x650000000002UL});
		public static readonly BitSet _additive_expression_in_shift_expression477 = new BitSet(new ulong[]{0x820000000002UL});
		public static readonly BitSet _41_in_shift_expression490 = new BitSet(new ulong[]{0x521C8D61E0UL});
		public static readonly BitSet _additive_expression_in_shift_expression494 = new BitSet(new ulong[]{0x820000000002UL});
		public static readonly BitSet _47_in_shift_expression503 = new BitSet(new ulong[]{0x521C8D61E0UL});
		public static readonly BitSet _additive_expression_in_shift_expression507 = new BitSet(new ulong[]{0x820000000002UL});
		public static readonly BitSet _multiplicative_expression_in_additive_expression536 = new BitSet(new ulong[]{0x5000000002UL});
		public static readonly BitSet _36_in_additive_expression544 = new BitSet(new ulong[]{0x521C8D61E0UL});
		public static readonly BitSet _multiplicative_expression_in_additive_expression548 = new BitSet(new ulong[]{0x5000000002UL});
		public static readonly BitSet _38_in_additive_expression556 = new BitSet(new ulong[]{0x521C8D61E0UL});
		public static readonly BitSet _multiplicative_expression_in_additive_expression560 = new BitSet(new ulong[]{0x5000000002UL});
		public static readonly BitSet _power_expression_in_multiplicative_expression584 = new BitSet(new ulong[]{0x8900000002UL});
		public static readonly BitSet _35_in_multiplicative_expression592 = new BitSet(new ulong[]{0x521C8D61E0UL});
		public static readonly BitSet _power_expression_in_multiplicative_expression596 = new BitSet(new ulong[]{0x8900000002UL});
		public static readonly BitSet _39_in_multiplicative_expression604 = new BitSet(new ulong[]{0x521C8D61E0UL});
		public static readonly BitSet _power_expression_in_multiplicative_expression608 = new BitSet(new ulong[]{0x8900000002UL});
		public static readonly BitSet _32_in_multiplicative_expression616 = new BitSet(new ulong[]{0x521C8D61E0UL});
		public static readonly BitSet _power_expression_in_multiplicative_expression620 = new BitSet(new ulong[]{0x8900000002UL});
		public static readonly BitSet _cast_expression_in_power_expression644 = new BitSet(new ulong[]{0x4000000000002UL});
		public static readonly BitSet _50_in_power_expression652 = new BitSet(new ulong[]{0x521C8D61E0UL});
		public static readonly BitSet _cast_expression_in_power_expression656 = new BitSet(new ulong[]{0x4000000000002UL});
		public static readonly BitSet _CAST_in_cast_expression678 = new BitSet(new ulong[]{0x200000000UL});
		public static readonly BitSet _33_in_cast_expression680 = new BitSet(new ulong[]{0x521CCD61E0UL});
		public static readonly BitSet _expression_in_cast_expression684 = new BitSet(new ulong[]{0x2000000000UL});
		public static readonly BitSet _37_in_cast_expression686 = new BitSet(new ulong[]{0x40000UL});
		public static readonly BitSet _type_expression_in_cast_expression690 = new BitSet(new ulong[]{0x400000000UL});
		public static readonly BitSet _34_in_cast_expression692 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _if_expression_in_cast_expression701 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _type_identifier_in_type_expression720 = new BitSet(new ulong[]{0x1000000000002UL});
		public static readonly BitSet _48_in_type_expression731 = new BitSet(new ulong[]{0x2002000000000UL});
		public static readonly BitSet _37_in_type_expression741 = new BitSet(new ulong[]{0x2002000000000UL});
		public static readonly BitSet _49_in_type_expression755 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _IDENTIFIER_in_type_identifier777 = new BitSet(new ulong[]{0x202UL});
		public static readonly BitSet _DOT_in_type_identifier783 = new BitSet(new ulong[]{0x40000UL});
		public static readonly BitSet _IDENTIFIER_in_type_identifier787 = new BitSet(new ulong[]{0x202UL});
		public static readonly BitSet _IF_in_if_expression807 = new BitSet(new ulong[]{0x200000000UL});
		public static readonly BitSet _33_in_if_expression809 = new BitSet(new ulong[]{0x521CCD61E0UL});
		public static readonly BitSet _expression_in_if_expression813 = new BitSet(new ulong[]{0x2000000000UL});
		public static readonly BitSet _37_in_if_expression815 = new BitSet(new ulong[]{0x521CCD61E0UL});
		public static readonly BitSet _expression_in_if_expression819 = new BitSet(new ulong[]{0x2000000000UL});
		public static readonly BitSet _37_in_if_expression821 = new BitSet(new ulong[]{0x521CCD61E0UL});
		public static readonly BitSet _expression_in_if_expression825 = new BitSet(new ulong[]{0x400000000UL});
		public static readonly BitSet _34_in_if_expression827 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _unary_expression_in_if_expression836 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _postfix_expression_in_unary_expression855 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _36_in_unary_expression866 = new BitSet(new ulong[]{0x521C8D61E0UL});
		public static readonly BitSet _cast_expression_in_unary_expression870 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _38_in_unary_expression878 = new BitSet(new ulong[]{0x521C8D61E0UL});
		public static readonly BitSet _cast_expression_in_unary_expression882 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _expression_in_argument_expression_list905 = new BitSet(new ulong[]{0x2000000002UL});
		public static readonly BitSet _37_in_argument_expression_list913 = new BitSet(new ulong[]{0x521CCD61E0UL});
		public static readonly BitSet _expression_in_argument_expression_list917 = new BitSet(new ulong[]{0x2000000002UL});
		public static readonly BitSet _primary_expression_in_postfix_expression941 = new BitSet(new ulong[]{0x1000200000202UL});
		public static readonly BitSet _48_in_postfix_expression949 = new BitSet(new ulong[]{0x521CCD61E0UL});
		public static readonly BitSet _argument_expression_list_in_postfix_expression953 = new BitSet(new ulong[]{0x2000000000000UL});
		public static readonly BitSet _49_in_postfix_expression955 = new BitSet(new ulong[]{0x1000200000202UL});
		public static readonly BitSet _33_in_postfix_expression963 = new BitSet(new ulong[]{0x400000000UL});
		public static readonly BitSet _34_in_postfix_expression965 = new BitSet(new ulong[]{0x1000200000202UL});
		public static readonly BitSet _33_in_postfix_expression973 = new BitSet(new ulong[]{0x521CCD61E0UL});
		public static readonly BitSet _argument_expression_list_in_postfix_expression977 = new BitSet(new ulong[]{0x400000000UL});
		public static readonly BitSet _34_in_postfix_expression979 = new BitSet(new ulong[]{0x1000200000202UL});
		public static readonly BitSet _DOT_in_postfix_expression987 = new BitSet(new ulong[]{0x40000UL});
		public static readonly BitSet _IDENTIFIER_in_postfix_expression989 = new BitSet(new ulong[]{0x1000200000202UL});
		public static readonly BitSet _IDENTIFIER_in_primary_expression1011 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _constant_in_primary_expression1018 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _33_in_primary_expression1025 = new BitSet(new ulong[]{0x521CCD61E0UL});
		public static readonly BitSet _expression_in_primary_expression1027 = new BitSet(new ulong[]{0x400000000UL});
		public static readonly BitSet _34_in_primary_expression1029 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _TRUE_in_constant1046 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _FALSE_in_constant1053 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _NULL_in_constant1060 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _DATETIME_LITERAL_in_constant1067 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _TIMESPAN_LITERAL_in_constant1074 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _HEX_LITERAL_in_constant1081 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _DECIMAL_LITERAL_in_constant1088 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _CHARACTER_LITERAL_in_constant1095 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _STRING_LITERAL_in_constant1102 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _FLOATING_POINT_LITERAL_in_constant1109 = new BitSet(new ulong[]{0x2UL});
	}
	#endregion Follow sets
}

} // namespace  Expressions.Flee 
